<!DOCTYPE HTML>
<html>
<head>
	<title>Wilana Calc</title>
	<meta charset="utf-8">
	<link rel='stylesheet' type='text/css' href='./static/style.css'>
	<link rel='stylesheet' type='text/css' href='./static/nv.d3.css'>
	<!---<link rel='stylesheet' type='text/css' href='./static/LineChart.css'>-->
	<script type="text/javascript" src="./client_modules/angular.js"></script>
	<script type="text/javascript" src="./client_modules/angular-route-1_5_5.js"></script>
	<script type="text/javascript" src="./client_modules/isaac.js"></script>
	<script type="text/javascript" src="./client_modules/bcrypt.js"></script>
	<script type="text/javascript" src="./client_modules/angular-animate.js"></script>
	<script type="text/javascript" src="./client_modules/d3.js"></script>
	<script type="text/javascript" src="./client_modules/nv.d3.js"></script>
	<script type="text/javascript" src="./client_modules/angular-nvd3.js"></script>
	<script type="text/javascript" src="./wc3_services.js"></script>
	<script src="https://apis.google.com/js/platform.js" async defer></script>
	<!--<script type="text/javascript" src="./client_modules/ng-google-signin.js"></script>-->
	<!--<script type="text/javascript" src="./LineChart.js"></script>-->
	<script>
	var myApp = angular.module("myApp", ['ngRoute', 'ngAnimate', 'nvd3', 'wc3_services']); // 'google-signin',
	var wc3_services = angular.module("wc3_services");
	var ngAnimate = angular.module("ngAnimate");

	/*myApp.config(['GoogleSigninProvider', function(GoogleSigninProvider){
		GoogleSigninProvider.init({
			client_id: "544028406258-p756lflvl7dqrap03ajh3kogfmc873pf.apps.googleusercontent.com"
		});
	}]);*/

	myApp.config(function($routeProvider){
		$routeProvider
			.when('/', {
				templateUrl: './partials/welcome.html'
			})
			.when('/login', {
				templateUrl: './partials/welcome.html'
			})
			.when('/matrix', {
				templateUrl: './partials/matrix_show.html'
			})
			.when('/reports', {
				templateUrl: './partials/reports.html',
				controller: 'reportsController'
			})
			.when('/transactions/new', {
				templateUrl: './partials/transactions_new.html'
			})
			.when('/transactions', {
				templateUrl: './partials/transactions_index.html',
				controller: 'transactionsIndexController'
			})
			.when('/dues_calc', {
				templateUrl: './partials/dues_calculator.html',
				controller: 'duesCalcController'
			})
			.when('/units', {
				templateUrl: './partials/units_index_new_edit.html'
			})
			.when('/taxes', {
				templateUrl: './partials/taxes.html',
				controller: 'taxesController'
			})
			.when('/mortgage', {
				templateUrl: './partials/mortgage.html',
				controller: 'mortgagesController'
			})
			.when('/spending/overview', {
				templateUrl: './partials/spending_overview.html',
				controller: 'expensesController'
			})
			.when('/spending/tables', {
				templateUrl: './partials/spending_tables.html',
				controller: 'expensesController'
			})
			.otherwise({
				redirectTo: '/partials/welcome.html'
			});
	});
	
	myApp.controller('appController', ['$scope', '$rootScope', '$location', 'userFactory', 'reportFactory', 'transactionFactory', function($scope, $rootScope, $location, userFactory, reportFactory, transactionFactory){	
		//console.log("loading appController");
		$scope.current_user = userFactory.current_user;
		$scope.logged_in = userFactory.logged_in;
		$scope.admin = userFactory.admin;
		if (!$scope.logged_in){
			$location.url("/login");
		}
		$scope.logout_result = "";
		$scope.nav_topic = userFactory.nav_topic;
		$scope.this_view = $location.url();
		$scope.updated_transaction = [];
		$scope.new_user = {};
		$scope.user_list = [];
		$scope.user_info = {};
		$scope.welcome_message = "";
		$scope.edit_user = false;
		//console.log("about to zero out updated_user");
		$scope.updated_user = {email: userFactory.email};
		$scope.report = "";
		$scope.today = new Date();
		$scope.date_for_sorting = transactionFactory.date_for_sorting;
		$scope.message_log = userFactory.message_log;
		$scope.show_this = false;
		$scope.page_titles = {
			'/': "User Login", 
			'/matrix': "Dues Matrix", 
			'/reports': "Account Balance", 
			'/transactions': "Transaction Browser", 
			'/transactions/new': "Transaction Entry", 
			'/units': "Unit Directory",
			'/login': "User Login",
		};
		$scope.this_page_title = $scope.page_titles[$location.url()];
		$scope.location = $location.url();
		userFactory.index(function(user_index){  //run the full version of this here (i.e. as-is).  preloaded version is better for things that don't run at startup.
			if (user_index.error){
				console.log("Error retrieving user list: " + user_index.error);
			} else {			
				$scope.user_list = user_index.users;
			}
		})
		$scope.login_info = {unit: "Admin", pw: 'Amasa7'};  //sets default login name.  remove for real use
		$scope.welcome = function(){
			if ($scope.admin === true){
				return "Hi, Admin!";
			} else if ($scope.current_user){
				return "Hi, Unit " + $scope.current_user + "!";
			} else {
				return "You are not logged in.";
			}
		}
		$scope.new_nav_topic = function(nav_topic){
			userFactory.nav_topic = nav_topic;
			$scope.nav_topic = userFactory.nav_topic;
			//console.log("new nav topic: " + nav_topic);
		}
		$scope.toggle_form = function(this_form){
			if ($scope.show_this === this_form){
				$scope.show_this = false;
			} else {
				$scope.show_this = this_form;
			}
		}
		$scope.register = function(user_info){
			userFactory.register(user_info, function(result){
				if (result.error){
					console.log("Error registering new user: " + result.error);
				} else {
					//console.log( "Registration completed.");
					$location.url('/reports');

				}
			})
		}
		$scope.login = function(login_info){
			userFactory.login(login_info, function(result){
				if (result.error){
					console.log(("Error during login: " + result.error));
				} else {
					$scope.logged_in = userFactory.logged_in;
					$scope.current_user = userFactory.current_user;
					$scope.email = userFactory.email;
					$scope.updated_user.email = userFactory.email;
					//console.log("updated_user is now " + JSON.stringify($scope.updated_user));
					$scope.admin = userFactory.admin;
					//console.log( "Login by email " + $scope.email + ", unit " + $scope.current_user + " completed.");
					$location.url('/reports');
				}
			})
		}
		$scope.login_psspt = function(){
			userFactory.login_psspt($scope.login_info, function(result){
				console.log('not yet implemented');
			})
		}
		$scope.login_GSi = function(){
			this_auth = gapi.auth2.init({
				client_id: "544028406258-p756lflvl7dqrap03ajh3kogfmc873pf.apps.googleusercontent.com",///  =  something?
				scope: 'email',
				fetch_basic_profile: false
			}); //.then()??
			//console.log(this_auth);
		};
		$scope.googlelogintest = function(){
			console.log("in user controller googlelogintest method");
			userFactory.googlelogintest(function(result){
				//console.log(result);
			})
		}
		$scope.load_gin = function(){
			console.log("in user controller load_gin method");
			var auth2 = gapi.auth2.getAuthInstance();
			auth2.signIn();
			//console.log("load_gin completed");
		}
		$scope.onSignIn = function(googleUser) { //not sure anything calls this yet
			console.log("in user controller onSignIn method");
  			var profile = googleUser.getBasicProfile();
  			//console.log('ID: ' + profile.getId()); // Do not send to your backend! Use an ID token instead.
 			//console.log('Name: ' + profile.getName());
 			//console.log('Image URL: ' + profile.getImageUrl());
			//console.log('Email: ' + profile.getEmail());
		}
		$scope.logout_google = function(){
			console.log("in user controller logout_google method");
 			var auth2 = gapi.auth2.getAuthInstance();
    		auth2.signOut().then(function () {
      			//console.log('User signed out.');
      		});
		}
		$scope.logout = function(){
			userFactory.logout({unit: userFactory.current_user}, function(result){
				if (result.error){
					console.log("Error during logout: " + result.error);
				} else if (result.logged_out){
					$scope.logged_in = false;
					$scope.current_user = "";
					$scope.admin = false;
					//console.log( "Logout completed.  These should all be false: " + $scope.logged_in + $scope.admin + userFactory.admin);
					$scope.welcome_message = "You have been logged out";
					$location.url("/");
				}
			})
		}
		$scope.logoff_many = function(){
			userFactory.logout_many($scope.user_list, function(result){
				//console.log( 'Mass logout result: ' + JSON.stringify(result));;
			})
		}
		$scope.update_user = function(){
			//console.log("in user controller, about to update password: " + JSON.stringify($scope.updated_user));;
			userFactory.update_user($scope.updated_user, function(result){
				if (result.error){
					console.log("Error updating user: " + result.error);
				} else {
					$scope.updated_user = {};
					$scope.edit_user = false;
					//console.log( 'User update completed.  Server response: ' + result.result);
				}
			})
		}
	}]);
	myApp.controller('duesCalcController', ['$scope', "expenseFactory", "mortgageFactory", "userFactory", function($scope, expenseFactory, mortgageFactory, userFactory){
		$scope.result = {};
		$scope.component = {tier: 0, flat: 0};
		$scope.shares = {studios: 2950, medium: 3950, large: 4500};
		$scope.scratch = {studios: {}, medium: {}, large: {}};
		$scope.find_dues = function(){
			for (key in $scope.shares){
				$scope.scratch[key].tier_comp = ($scope.shares[key] / 96950) * $scope.component.tier;
				$scope.scratch[key].flat_comp = $scope.component.flat / 27;
				$scope.scratch[key].unrounded = $scope.scratch[key].tier_comp +  $scope.scratch[key].flat_comp;
				$scope.scratch[key].rounded = Math.round($scope.scratch[key].unrounded / 60) * 60;
				$scope.result[key] = $scope.scratch[key].rounded / 12;
				console.log($scope.scratch[key].tier_comp + ", " + $scope.scratch[key].flat_comp + ", " + $scope.scratch[key].unrounded + ", " + $scope.scratch[key].rounded + ", " + $scope.result[key]);
			}
		}
		expenseFactory.index("duesCalc", function(calc_components){
			mortgageFactory.index_by_year("duesCalc", function(these_mortgage_expenses){
				$scope.component = {tier: calc_components.tier.toFixed(2), flat: (calc_components.flat + these_mortgage_expenses).toFixed(2)};
				$scope.find_dues();
			})
		});
	}])
	myApp.controller('expensesController', ['$scope', 'expenseFactory', 'balanceHistoryFactory', 'mortgageFactory', function($scope, expenseFactory, balanceHistoryFactory, mortgageFactory){
		var today = new Date();
		var heard_from = {"mortgageFactory": false, "expenseFactory": false};
		var partial_expense_data = [];
		var expense_detail_data = {maintenance: [], utilities: [], other_expenses: []};
		$scope.new_line = {};
		$scope.these_years = {}; 
		$scope.current_categories = [];
		$scope.show_these = {maintenance: false, new_line_form: false};
		$scope.checked_all = false;
		$scope.chart_data = {};
		$scope.recorded_incomes = {};
		$scope.expense_chart_options = {};
		$scope.income_chart_options = {};
		$scope.expense_chart_data = [];
		$scope.income_chart_data = [];
		$scope.new_balance_history = {};
		$scope.balance_histories_data = [];
		for (year=2007;year<=today.getFullYear();year++){
			$scope.these_years[year] = {};
		}
		expenseFactory.index("expenses", function(new_index){
			if (new_index.error){
				console.log("Error retrieving spending history index.");
			} else {
				expense_detail_data.maintenance = new_index.expense_chart_detail.maintenance_subcategories;
				expense_detail_data.utilities = new_index.expense_chart_detail.utilities_subcategories;
				expense_detail_data.other_expenses = new_index.expense_chart_detail.other_expenses_subcategories;
				partial_expense_data = partial_expense_data.concat(new_index.expense_chart_data);
				if (heard_from["mortgageFactory"] === true){				//this is a convoluted attempt to get the chart to render correctly, since I'm having difficulty getting sequentially added data compiled correctly.   if mortgagefactory has reported, we need to collect its data before overwriting scope objects
					//$scope.supercategory_index.Mortgage.Total["2017"] = new_index.by_supercategory.Mortgage.Total["2017"];
					//new_index.by_supercategory.Mortgage.Total = $scope.supercategory_index.Mortgage.Total;
					//new_index.expense_chart_data[0].values = new_index.expense_chart_data[0].values.concat(partial_expense_data[2].values) //add budgeted mortgage total to pre-arrived mortgage history
					//the above is an attempt to bring budgeted mortgage total into expense chart format. But chart does not yet support mortgage totals, and that seems low priority - FAR easier to just budget for interest & principal
					//console.log("heard from mortgage factory first");
					$scope.expense_chart_data = partial_expense_data;
				}
				$scope.supercategory_index = new_index.by_supercategory;
				heard_from["expenseFactory"] = true;
				$scope.income_chart_data = $scope.income_chart_data.concat(new_index.income_chart_data);
				//console.log("Lots of indexes:  Supercat, expense_chart, income_chart: ");
				//console.log(new_index);
				$scope.chart_options = {
					'chart': {
						"type": 'stackedAreaChart',
						"height": 450, 
						"width": 925,
						"margin": {
							top: 20,
							right: 20,
							bottom: 30,
							left: 90
						},
						"x": function(d){return d[0];},
						"y": function(d){return d[1];},
						"useVoronoi": false,
						"clipEdge": true,
						"duration": 400,
						useInteractiveGuideline: true,
						xAxis: {
							showMaxMin: false,
							tickFormat: function(d){
								if (d === 2017){
									d = "Budget " + String(d);
								}
								return (d);
								//return d3.time.format('%x')(new Date(d))
							}
						},
						yAxis: {
							tickFormat: function(d){
								return ("$" + d3.format(',.2f')(d));
							}
						},
						zoom: {
							enabled: false,
							scaleExtent: [1,10],
							useFixedDomain: false,
							useNiceScale: false,
							horiontalOff: false,
							verticalOff: true,
							unzoomEventType: 'dblclick.zoom'
						}
					}
				};
				//$scope.income_chart_options =  {"axes":{"x":{"key":"year"}},"series": chart_series};
				//console.log("final chart_options: " + JSON.stringify($scope.expense_chart_options));
			}
		})
		expenseFactory.get_recorded_incomes(function(result){
			$scope.recorded_incomes = result.incomes;
		})
		mortgageFactory.index_by_year("expenses", function(result){
			//$scope.expense_chart_data.push(result.for_chart[0]);
			//$scope.expense_chart_data.push(result.for_chart[1]); //   this leaves off total for now
			partial_expense_data = partial_expense_data.concat(result.for_chart.slice(0,2)); 
			heard_from["mortgageFactory"] = true;
			if (heard_from["expenseFactory"] === true){
				//console.log("Heard from expense factory first");
				$scope.expense_chart_data = partial_expense_data;
			}
			$scope.supercategory_index.Mortgage = result.for_table.Mortgage;  //then you can overwrite the carrier of the budgeted value.
			//console.log("Done adding mortgage to expense data:");
			//console.log(partial_expense_data);

		})
		balanceHistoryFactory.index(function(these_histories){
			if (these_histories.error){
				console.log("Error retrieving balance history index");
			} else {
				$scope.balance_histories_data = these_histories.histories_for_chart;
				$scope.balance_histories_options = {
					"chart": {
						"type": "multiChart",
						"height": 450,
						"margin": {
							"top": 20,
							"right": 60,
							"bottom": 30,
							"left": 120
						},
						//"useVoronoi": false,
						//"clipEdge": true,
						//"staggerLabels": true,
						"duration": 100,
						//"useInteractiveGuideline": true,
						"xAxis": {
							"showMaxMin": false,
							tickFormat: function(d){
								return d3.time.format('%x')(new Date(d))
							}
						},
						"yAxis1": {
							tickFormat: function(d){
								return ("$" + d3.format(',.2f')(d))
							}
						},
						"yAxis2": {
						}
					}
						/*"zoom": {
							"enabled": true,
							"scaleExtent": [
								1,
								10
							],
							"useFixedDomain": false,
							"useNiceScale": false,
							"horizontalOff": false,
							"verticalOff": true,
							"unzoomEventType": "dblclick.zoom"
						}*/
				/*{
					'chart': {
						"type": 'stackedAreaChart',
						"height": 200, 
						"margin": {
							top: 20,
							right: 60,
							bottom: 30,
							left: 120
						},
						"x": function(d){return d[0];},
						"y": function(d){return d[1];},
						"useVoronoi": false,
						"clipEdge": true,
						"duration": 400,
						useInteractiveGuideline: true,
						xAxis: {
							showMaxMin: false,
							tickFormat: function(d){
								return d3.time.format('%x')(new Date(d))
							}
						},
						yAxis: {
							tickFormat: function(d){
								return ("$" + d3.format(',.2f')(d));
							}
						},
						zoom: {
							enabled: false,
							scaleExtent: [1,10],
							useFixedDomain: false,
							useNiceScale: false,
							horiontalOff: false,
							verticalOff: true,
							unzoomEventType: 'dblclick.zoom'
						}
					}*/
				};
				//console.log("balance histories options:");
				//console.log($scope.balance_histories_options);
				//console.log("balance histories data:");
				//console.log($scope.balance_histories_data);
			}
		})
		$scope.toggle = function(element){
			$scope.show_these[element] = !$scope.show_these[element];
			//console.log($scope.show_these);
		}
		$scope.expense_view = function(this_view){
			if (this_view === "overview"){
				$scope.expense_chart_data = partial_expense_data;
			} else {
				$scope.expense_chart_data = expense_detail_data[this_view];
			}
		}
		$scope.check_all = function(){		//checks all years that are fully complete as true
			if (!$scope.checked_all){
				for (year=2007;year<today.getFullYear();year++){
					$scope.these_years[year].included = true;
				}
			} else {
				for (year=2007;year<today.getFullYear();year++){
					$scope.these_years[year].amount = "";
					$scope.these_years[year].included = false;
				}
			}
			$scope.checked_all = !$scope.checked_all;
		}
		$scope.create_budget_line = function(this_new_line){
			this_new_line.values = {};
			var valid_entry = true;
			if (!this_new_line.category){
				console.log("Budget category must have a name.");
				valid_entry = false;
			} else {
				for (i=2007;i<=today.getFullYear();i++){
					if ($scope.these_years[i].included){
						if (!Number($scope.these_years[i].amount) && (Number($scope.these_years[i].amount) != 0)){
							console.log('Year ' + i + ' must be given a numerical value.');
							valid_entry = false;
						} else {
							this_new_line.values[i] = Number($scope.these_years[i].amount);
						}
					}
				}
			}
			if (valid_entry){
				expenseFactory.create_budget_line(this_new_line, function(result){
					if (result.error){
						console.log("Error creating new budget line: " + err);
					} else {
						$scope.supercategory_index = result.by_supercategory;
					}
				})
			}
		}
		$scope.create_balance_history = function(this_new_history){
			this_new_history.dates = this_new_history.dates.split('\n');
			this_new_history.values = this_new_history.values.split('\n');
			if ((this_new_history.dates.length === this_new_history.values.length) && (this_new_history.dates.length > 0)){
				balanceHistoryFactory.create(this_new_history, function(result){
					if (result.error){
						console.log("Error creating balance history: " + result.error);
					} else {
						console.log("Balance history created with no errors detected.");
						$scope.new_balance_history = {};
					}
				})
			} 
		}
	}]);
	myApp.controller('matrixesController', ['$scope', 'matrixFactory', 'userFactory', function($scope, matrixFactory, userFactory){
		$scope.dues_matrix = [];
		$scope.month_labels = matrixFactory.count_months();
		$scope.dues_matrix = {};
		$scope.show_update_form = false;
		$scope.new_dues_info = {unit_number: "", month: "", year: "", amount: null};
		matrixFactory.index(function(data){
			if (data.error){
				console.log("Error retrieving dues rates: " + data.error);
			} else {
				$scope.dues_matrix = data;
				//console.log( 'Dues rate matrix loaded.');
			}
		})
		$scope.append = function(){
			matrixFactory.append($scope.new_dues_info, function(result){
				console.log("Factory response received: " + JSON.stringify(result));
				$scope.new_dues_info.unit_number = "";
				$scope.new_dues_info.amount = null;
			})
		}
	}]);
	myApp.controller('mortgagesController', ['$scope', 'mortgageFactory', 'userFactory', function($scope, mortgageFactory, userFactory){
		$scope.new_mortgage = {};
		$scope.parsed_mortgage = {};
		$scope.mortgage_index = [];
		$scope.main_data = "";
		mortgageFactory.mortgage_index(function(result){
			if (result.error){
				console.log(result.error);
			} else {
				//console.log("Retrieved mortgage index of length " + result.these_complete_mortgages.length);
				$scope.mortgage_index = result.these_complete_mortgages;	
				//console.log("mortage_index:");
				//console.log($scope.mortgage_index);	
				$scope.mortgage_chart_data = [];
				var key_mortgage = {};
				var fortune_mortgage = {};
				//var this_series_data = [];  // 
				var these_payments = []; //not a new entity, just a shortened name for each mortgage's data series
				//$scope.chart_options = {axes: {x: {key: "x", type: "date"}}};
				//var chart_series = {};  //several of these (one per mortgage) will be added to $scope.chart_options.
				var series_colors = {"Key Bank Mortgage": "rgb(144,24,21)", "Fortune Bank Loan": "rgb(60,36,175)"};
				$scope.mortgage_chart_options = {
					"chart": {
						"type": "lineChart",
						"height": 720,
						"width": 1150,
						"margin": {
							"top": 20,
							"right": 40,
							"bottom": 30,
							"left": 120
						},
						"x": function(d){ return d[0];},
						"y": function(d){ return d[1];},
						"duration": 100,
						"useInteractiveGuideline": true,
						"xAxis": {
							"showMaxMin": true,
							tickFormat: function(d){
								return d3.time.format('%x')(new Date(d));
							}
						},
						"yAxis": {
							tickFormat: function(d){
								return ("$" + d3.format(',.2f')(d/100));
							}
						},
						"zoom": {
							"enabled": false
						}
					}

				};
				if ($scope.mortgage_index[0].name === "Key Bank Mortgage"){
					key_mortgage = $scope.mortgage_index[0];
					fortune_mortgage = $scope.mortgage_index[1];
				} else if ($scope.mortgage_index[0].name === "Fortune Bank Loan"){
					key_mortgage = $scope.mortgage_index[1];
					fortune_mortgage = $scope.mortgage_index[0];
				} else {
					//console.log("Something is very wrong with mortgage parsing.");
				}
				$scope.mortgage_chart_prep = [{
					"key": key_mortgage.name, 
					"color": series_colors[key_mortgage.name], 
					"values": []
				}, {
					"key": fortune_mortgage.name, 
					"color": series_colors[fortune_mortgage.name], 
					"values": []
				}];
				for (month_index=0;month_index<key_mortgage.payments.length;month_index++){ // iterates through every month constructing data series,
					var new_datum = [new Date(key_mortgage.payments[month_index].pay_date), key_mortgage.running_balances[month_index]];
					$scope.mortgage_chart_prep[0].values.push(new_datum);
				}
				for (month_index=0;month_index<fortune_mortgage.payments.length;month_index++){
					var new_datum = [];
					new_datum.push(new Date(fortune_mortgage.payments[month_index].pay_date));
					new_datum.push(fortune_mortgage.running_balances[month_index]);
					$scope.mortgage_chart_prep[1].values.push(new_datum);					
				}
				$scope.mortgage_chart_data.push($scope.mortgage_chart_prep[0]);
				$scope.mortgage_chart_data.push($scope.mortgage_chart_prep[1]);  // when finished with the last month, tacks the series onto a permanent site, and starts again
				//console.log("mortgage chart data:");
				//console.log($scope.mortgage_chart_data);
			}
		});
		/*

					//	if (month_index === (these_payments.length - 1)){
					//		chart_series.values = this_series_data;
						//console.log("starting month_index " + month_index);
				//for (this_index=0;this_index<$scope.mortgage_index.length;this_index++){ // yeah "this_index" is vague, but my usual scheme would be to call it "mortgage_index", which obviously wouldn't work here.
				//	var this_mortgage = $scope.mortgage_index.pop();
				//	console.log("after pop:");
				//	console.log($scope.mortgage_index);
				//	chart_series.key = this_mortgage.name;
				//	chart_series.color = series_colors[chart_series.key];				this for loop has been impossible to coordinate.  this_index is always max value.
						//dataset: $scope.mortgage_index[this_index].name, 
						//color: series_colors[this_index],
						//key: $scope.mortgage_index[this_index].name, 
						//label: "Remaining Balance", 
						//type: "line"
					//this_series_data = [{x: new Date(this_mortgage.initial_date), "balance": this_mortgage.initial_balance}];
					//these_payments = this_mortgage.payments;			//if (this_index === ($scope.mortgage_index.length -1)){ // if done iterating through all the mortgages
								//$scope.chart_options["series"] = chart_series;
								//console.log("chart_data: " + JSON.stringify($scope.chart_data));
								//console.log("chart_options: " + JSON.stringify($scope.chart_options));
							//}
					//}
					//}
				}
*/
		$scope.parse_mortgage = function(this_new_mortgage){
			$scope.parsed_mortgage.name = this_new_mortgage.name;
			$scope.parsed_mortgage.initial_date = new Date(this_new_mortgage.initial_date);
			$scope.parsed_mortgage.initial_balance = Number(this_new_mortgage.initial_balance);
			var raw_payment_list = this_new_mortgage.raw_payments.split('\n');
			$scope.parsed_mortgage.payments = [];
			$scope.parsed_mortgage.running_balances = [];
			for (i=0;i<raw_payment_list.length;i++){
				var these_payment_properties = raw_payment_list[i].split('\t');
				if (these_payment_properties.length != 4){
					console.log("Error in mortgage payment format: too few properties at " + these_payment_properties);
				} else if (Number(these_payment_properties[1]) != (Number(these_payment_properties[2]) + Number(these_payment_properties[3])).toFixed(2)){
					console.log("Error in mortgage payment property amounts at: " + these_payment_properties + ".  I don't think " + Number(these_payment_properties[1]) + " equals " + (Number(these_payment_properties[2]) + Number(these_payment_properties[3])).toFixed(2));
				} else {
					$scope.parsed_mortgage.payments.push({
						'pay_date': new Date(these_payment_properties[0]), 
						'total': Number(these_payment_properties[1]), 
						'interest': Number(these_payment_properties[2]), 
						'principal': Number(these_payment_properties[3])
					});
					if ($scope.parsed_mortgage.running_balances.length === 0){			
						$scope.parsed_mortgage.running_balances.push(($scope.parsed_mortgage.initial_balance - $scope.parsed_mortgage.payments[0].principal).toFixed(2));
					} else {
						$scope.parsed_mortgage.running_balances.push(($scope.parsed_mortgage.running_balances[i-1] - $scope.parsed_mortgage.payments[i].principal).toFixed(2));
					}
				}
			}
		}
		$scope.create_mortgage = function(){
			if ($scope.parsed_mortgage === {}){
				$scope.parse_mortgage($scope.new_mortgage)
			}
			mortgageFactory.create_mortgage($scope.parsed_mortgage, function(result){
				if (result.error){
					console.log(result.error);
				} else {
					if (result.created_mortgage){
						$scope.mortgage_index.push(result.created_mortgage);
					}
					$scope.new_mortgage = {};
					$scope.parsed_mortgage = {};
					//console.log("Mortgage created?  Result: " + JSON.stringify(result));
				}
			})
		}
		$scope.show_mortgage = function(index){
			if (index === "new"){
				$scope.main_data = {'new': true};
			} else {
				$scope.main_data = {'show': index};
				$scope.show_this_mortgage = $scope.mortgage_index[index];
			}
		}	
	}]);
	myApp.controller('reportsController', ['$scope', 'reportFactory', 'transactionFactory', 'unitFactory', 'userFactory', function($scope, reportFactory, transactionFactory, unitFactory, userFactory){
		$scope.date_for_sorting = transactionFactory.date_for_sorting;
		$scope.active_unit_button = "";
		$scope.admin = userFactory.admin;
		$scope.current_user = userFactory.current_user;
		$scope.chart_data = {};
		$scope.report_format = "";
		$scope.generate_report = function(this_unit_number){
			if (!this_unit_number){
				console.log("Please select a unit number.");
			} else {
				$scope.reported_unit = this_unit_number;
				reportFactory.full_history(this_unit_number, function(result){
					$scope.this_report = result.full_history;					
					$scope.initial_balance = result.initial_balance;
					$scope.report_chart_options = result.chart_options;
					$scope.report_chart_data = [result.chart_data];
					//console.log($scope.report_chart_data);
					//console.log( 'Report on unit ' + this_unit_number + " generated.");
				})
			}
		}
		if (!$scope.admin && $scope.current_user){
			$scope.generate_report($scope.current_user);
		}
		unitFactory.numbers_index(function(unit_numbers_index){
			if (unit_numbers_index.error){
				console.log("Error retrieving unit numbers: " + unit_numbers_index.error);
			} else {
				$scope.unit_numbers = unit_numbers_index.unit_numbers;
			}
		})
		unitFactory.index({"deposits": true}, function(result){
			if (result.error){
				console.log("Error retrieving deposits: " + result.error);
			} else {
				$scope.deposit_index = result.deposit_index;
			}
		})
		reportFactory.balance_summary(function(result){
			if (result.error){
				console.log("Error retrieving balances summary: " + result.error);
			} else {
				$scope.these_balances = result;
				//console.log( 'Unit balance summary retrieved.');
				if (!$scope.admin && $scope.current_user){
					$scope.shareholder_balance_list = {};
					$scope.balance_total = 0;
					$scope.total_unit_count = Object.keys($scope.these_balances).length;
					for (i=0;i<$scope.total_unit_count;i++){
						if ($scope.shareholder_balance_list[String($scope.these_balances[Object.keys($scope.these_balances)[i]])]){  //complicated way of querying whether each unit's balance value is on the non-admin balance list yet.
							$scope.shareholder_balance_list[String($scope.these_balances[Object.keys($scope.these_balances)[i]])] += 1;
						} else {
							$scope.shareholder_balance_list[String($scope.these_balances[Object.keys($scope.these_balances)[i]])] = 1;
						}
						$scope.balance_total += Number($scope.these_balances[Object.keys($scope.these_balances)[i]]);
					}
				}
			}
		})
		$scope.unit_button_click = function(unit_number){
			$scope.active_unit_button = unit_number;
			$scope.generate_report(unit_number);
		}
		$scope.report_chart_options = {
			"chart": {
				"type": "lineChart",
				"height": 720,
				"width": 1025, 
				"top": 20,
				"right": 40,
				"bottom": 30,
				"left": 120
			},
			"x": function(d){ return d[0];},
			"y": function(d){ return d[1];},
			"duration": 100,
			"useInteractiveGuideline": true,
			"xAxis": {
				"showMaxMin": true,
				tickFormat: function(d){
					return d3.time.format('%x')(new Date(d));
				}
			},
			"yAxis": {
				tickFormat: function(d){
					return ("$" + d3.format(',.2f')(d/100));
				}
			},
			"yDomain": [-5000, 1000],
			"zoom": {
				"enabled": false
			}
		};
		//console.log($scope.report_chart_options);
	}]);
	myApp.controller('taxesController', ['$scope', 'propertyTaxFactory', 'mortgageFactory', function($scope, propertyTaxFactory, mortgageFactory){
		$scope.new_tax = {};
		$scope.new_tax_options = {};
		$scope.official_calcs = {small: [992.19,736.37,848.34,1021.00,1204.92,1274.59, 1379.46], medium: [992.19, 985.98, 1135.92, 1354.74, 1613.37, 1690.65, 1847.08], large: [992.19, 1123.27, 1294.08, 1538.30, 1838.01, 1919.49, 2104.27]};  // these are from a summary xls but they conflict with single year sheets
		propertyTaxFactory.index(function(prop_tax){
			if (prop_tax.error){
				console.log("Error retrieving property taxes: " + prop_tax.error);
			} else {
				$scope.property_taxes_by_attribute = prop_tax.index_by_attribute;
				console.log($scope.property_taxes_by_attribute);
			}
		})
		$scope.create_tax = function(this_tax_info){
			if ($scope.new_tax_options.lost_shareholder){
				this_tax_info.units_main = {'small': [6, 7, 8, 9, 15, 16, 17, 18, 24, 25, 26, 27], 'medium': [2, 10, 11, 19, 20, 28, 29], 'large': [4, 5, 12, 14, 21, 22]};
			}
			propertyTaxFactory.create_tax(this_tax_info, function(creation_result){
				if (creation_result.error){
					console.log("Error creating tax year: " + creation_result.error);
				} else {
					$scope.property_taxes_by_attribute = creation_result.index_by_attribute;
				}
			})
		}
		$scope.delete_tax = function(this_tax_id){
			propertyTaxFactory.delete_tax(this_tax_id, function(deletion_result){
				if (deletion_result.error){
					console.log("Error deleting tax year: " + deletion_result.error);
				} else {
					$scope.property_taxes_by_attribute = deletion_result.index_by_attribute;
				}
			})
		}
	}]);
	myApp.controller('transactionsIndexController', ['$scope', '$filter', 'filterFactory', 'transactionFactory', 'unitFactory', 'userFactory', function($scope, $filter, filterFactory, transactionFactory, unitFactory, userFactory){
		$scope.edit_lock = {type: false, id: null};
		$scope.updated_transaction = {};
		$scope.unit_labels = unitFactory.unit_numbers;
		$scope.filtered_index = [];
		console.log($scope.unit_labels);
		$scope.selected_filters = {
			"by_unit": {
				selected: false, 
			}, 
			"by_date": {
				selected: false, 
				start_date: "", 
				end_date: ""
			}, 
			"by_type": {
				selected: false, 
			}, 
			"by_amount": {
				selected: false,
				max: null,
				min: null
			}, 
			"by_check": {
				selected: false,
				number: ""
			}, 
			"by_notes": {
				selected: false,
				keyword: ""
			}
		};
		for (unit_index in $scope.unit_labels){
			$scope.selected_filters.by_unit[String($scope.unit_labels[unit_index])] = false;
		}
		for (type_index in transactionFactory.allowed_types){
			$scope.selected_filters.by_type[transactionFactory.allowed_types[type_index]] = false;
		}
		$scope.toggle_filter_selection = function(filter_type, filter_value){
			$scope.selected_filters[filter_type][filter_value] = !$scope.selected_filters[filter_type][filter_value];
			console.log($scope.selected_filters);
		}
		$scope.apply_filters = function(){
			var active_filters = [];
			var working_index = [];
			var apply_filter_sequence= function(current_list, current_filter, filter_params){
				console.log("Done with filter " + current_filter + " aka " + active_filters.shift());
				if (active_filters.length > 0){
					apply_filter_sequence(current_list, active_filters[0], filter_params);
				} else {
					$scope.filtered_index = current_list;
				}
			}
			for (key in $scope.selected_filters){
				if ($scope.selected_filters[key].selected === true){
					active_filters.push(key);
				}
			}
			if (active_filters.length > 0){
				if (working_index === []){
					working_index = $scope.transactions_and_dues_index;
				}
				apply_filter_sequence(working_index, active_filters[0], $scope.selected_filters);
			}
		}

		$scope.proposed_filters = filterFactory.proposed_filters;
		if (filterFactory.saved_filters){
			filterFactory.saved_filters.restore($scope.proposed_filters);
		}
		$scope.active_filters = filterFactory.placeholder_filters;
		$scope.unit_buttons = [];
		$scope.type_buttons= [];
		var bump_tell_count_tic = function(){  //for loop indexer slightly modified to be a unit-number iterator for times when it's just not worth the asynchrony trouble to do a server call.
			var start_index = 0;
			var bump = function(bump_tell_count){
				if (bump_tell_count === 'reset'){
					start_index = 0;
					return ("ok");
				} else if (start_index > 29){
					//console.log("Error: bump_tell_count_tic is being forced to iterate too high");
					return ({error: "No mure units to iterate"});
				} else if (bump_tell_count == "tell" && start_index === 29){
					//console.log("bump_tell_count_tic has reached the last unit");
					return (start_index);
				} else if (bump_tell_count == "tell"){
					return (start_index);
				} else if (bump_tell_count == "count"){
					return 27;
				} else if (bump_tell_count == "bump" && (start_index === 12 || start_index === 22)){
					return (start_index += 2);
				} else if (bump_tell_count == "bump" && (start_index === 29)){
					return (start_index = 1);
				} else if (bump_tell_count == "bump"){
					return (start_index += 1);
				}
			}
			return bump;
		}();
		var transaction_types = transactionFactory.allowed_types;
		$scope.or_filter = function(this_column_value, criteria){ // criteria should be a single-key object with values as a list (i.e. {unit: [7,8]})
			//console.log("Or_filter called comparing " + JSON.stringify(this_column_value) + " with " + JSON.stringify(criteria));
			var match = false;
			if (criteria.length < 1){
				//console.log("Skipping filter of " + JSON.stringify(this_column_value) + " because " + JSON.stringify(criteria) + " is empty");
				//console.log(JSON.stringify($scope.proposed_filters));
				return true;
			} else {
				for (term_index=0; term_index<criteria.length;term_index++){
					if (this_column_value === criteria[term_index]){  // if the key-designated column in the transaction is an exact match with any item in the criteria list
						match = true;
						//console.log("I think " + this_transaction[Object.keys(criteria)[0]] + " equals " + criteria[Object.keys(criteria)[0]][term_index]);
					}
					//console.log("I think " + this_transaction[Object.keys(criteria)[0]] + " does NOT equal " + criteria[Object.keys(criteria)[0]][term_index]);
				}
			}
			return match;
		}
		//var unit_numbers = unitFactory.numbers_index;
		for (i=0;i<bump_tell_count_tic("count");i++){
			$scope.unit_buttons.push({name: bump_tell_count_tic('bump'), label: bump_tell_count_tic('tell'), button_type: "unit"});
			//console.log("Unit button born: " + JSON.stringify($scope.unit_buttons[($scope.unit_buttons.length -1)]));
		}
		$scope.type_translations = {'dues': 'dues', 'credit': 'credits', 'late_fee': 'late fees', 'other_fee': 'other fees', 'assessment': 'assessments'};
		for (i=0;i<transaction_types.length;i++){
			$scope.type_buttons.push({name: transaction_types[i], label: $scope.type_translations[transaction_types[i]], button_type: "type"});
			//console.log("Type button born: " + JSON.stringify($scope.type_buttons[($scope.type_buttons.length -1)]));
		}
		$scope.apply_filters_old = function(){
			//console.log("transactions controller apply filters method activated");
			$scope.proposed_filters.activate($scope.active_filters);
			filterFactory.saved_filters = $scope.active_filters;
			//console.log("proposed filter status: " + JSON.stringify($scope.proposed_filters));
			//console.log("active filter at end of filter application: " + JSON.stringify($scope.active_filters));
		}
		$scope.toggle_proposed_filter = function(attribute, value){  // old
			if (attribute === "unit" || attribute === "type"){
				if (!$scope.proposed_filters[attribute]){
					$scope.proposed_filters[attribute] = [];
				}
				var value_index = $scope.proposed_filters[attribute].indexOf(value);
				if (value_index === -1){
					$scope.proposed_filters[attribute].push(value);
				} else {
					$scope.proposed_filters[attribute].splice(value_index, 1);
					if ($scope.proposed_filters[attribute].length === 0){
						$scope.proposed_filters[attribute] = false;
					}
				}
			}
		}
		transactionFactory.index(function(factory_response){
			//console.log("transactions index controller has called transaction factory index");
			$scope.transactions_and_dues_index = factory_response.transactions_and_dues_index; 
		});
		$scope.date_for_sorting = transactionFactory.date_for_sorting;
		$scope.sort_criterion = "-date";
		var reverse_sort_strings = {
			"date": "-date", 
			"-date" : "date", 
			"_unit.number": "-_unit.number", 
			"-_unit.number": "_unit.number", 
			"amount": "-amount", 
			"-amount": "amount", 
			"check_number": "-check_number", 
			"-check_number": "check_number", 
			"type": "-type", 
			"-type": "type", 
			"notes": "-notes", 
			"-notes": "notes"
		}
		//console.log("proposed filter status: " + JSON.stringify($scope.proposed_filters));
		$scope.sort_by = function(new_criterion){
			if (new_criterion.search($scope.sort_criterion) != -1){ //if user is just reversing the sort order
				$scope.sort_criterion = reverse_sort_strings[$scope.sort_criterion];
			} else {  // if user is sorting by a new column
				$scope.sort_criterion = new_criterion;
			} 
		}
		$scope.cancel = function(){
			$scope.edit_lock = {type: false, id: null};
			$scope.updated_transaction = {};
			console.log( 'Action canceled.');
		}
		$scope.edit_transaction = function(this_transaction){
			$scope.updated_transaction = {
				_id: this_transaction._id, 
				_unit: this_transaction._unit, 
				date: this_transaction.date, 
				type: this_transaction.type, 
				amount: (this_transaction.amount / 100).toFixed(2), 
				check_number: this_transaction.check_number, 
				notes: this_transaction.notes
			};
			$scope.edit_lock = {type: "edit", id: this_transaction._id};
			console.log( 'Transaction prepped for editing.');
		}
		$scope.update_transaction = function(updated_transaction, transaction_id){
			transactionFactory.update(updated_transaction, function(result){
				if (result.error){
					console.log("Update error: " + result.error);
				} else {
					console.log("Update completed.  About to refresh transactions.");
					transactionFactory.index(function(factory_response){
						$scope.transactions_and_dues_index = factory_response.transactions_and_dues_index; // depending on context, this will be an object with any of these:  message: string, filtered_transactions: array, sums: {sum: Number, running_balances: list}
					});
				}
			})
			$scope.edit_lock = {type: false, id: null};
			$scope.updated_transaction = {};
		}
		$scope.prepare_delete = function(id){
			$scope.edit_lock = {type: "delete", id: id};
		}
		$scope.delete_transaction = function(this_transaction, this_unit){
			transactionFactory.delete_one(this_transaction._id, function(result){
				if (result.error){
					console.log("Error deleting transaction: " + result.error);
				} else {
					transactionFactory.index(function(factory_response){
						$scope.transactions_and_dues_index = factory_response.transactions_and_dues_index;
					});
					$scope.edit_lock = {type: false, id: null};
					//console.log( "Transaction deleted.  Server response: " + JSON.stringify(result.result));
				}
			})
		}
	}]);
	myApp.controller('transactionsNewController', ['$scope', 'transactionFactory', 'unitFactory', 'userFactory', function($scope, transactionFactory, unitFactory, userFactory){
		$scope.display_prep = {};
		$scope.allowed_types = transactionFactory.allowed_types;
		$scope.delete_confirmation_pending = false;
		$scope.retain_form_entries = false;
		$scope.clear_check_number = function(){
			if ($scope.new_transaction.type != "credit"){
				$scope.new_transaction.check_number = "";
			}
		}
		unitFactory.numbers_index(function(data){
			if (data.error){
				console.log("Error retrieving unit numbers: " + data.error);
			} else {
				$scope.unit_list = data.unit_numbers;
			}
		})
		$scope.add_tab = function(){
			$scope.update_input = $scope.update_input + "\t";
			$scope.$broadcast("tab_added");
			//console.log("should have broadcast tab_added");
		}
		$scope.delete_all = function(){
			$scope.delete_confirmation_pending = false;
			transactionFactory.delete_all(function(result){
				if (result.error){
					console.log("Error while mass deleting: " + JSON.stringify(result.error));
				} else {
					//console.log( "All transactions deleted.  Server response: " + JSON.stringify(result));
				}
			})
		}
		$scope.prepare_update = function(){
			while ($scope.update_input.includes("$")){
				$scope.update_input = $scope.update_input.replace("$", "");
			}
			while ($scope.update_input.includes(",")){
				$scope.update_input = $scope.update_input.replace(",", "");
			}
			var raw_update = {};
			raw_update.lines = $scope.update_input.split('\n');
			for (i=0; i<raw_update.lines.length; i++){
				raw_update.lines[i] = raw_update.lines[i].split('\t');
			}
			for (i=1;i<raw_update.lines[0].length;i++){
				var this_date = new Date(raw_update.lines[0][i]);
				raw_update.lines[0][i] = this_date.toLocaleDateString();
			}
			if (raw_update.lines.length < 2){
				console.log("Update must contain at least 2 lines.");
			} else {
				$scope.display_prep = raw_update.lines;
				console.log( "New transactions prepared for upload.");
			}
		}
		$scope.create_transactions = function(){
			while ($scope.update_input.includes("$")){
				$scope.update_input = $scope.update_input.replace("$", "");
			}
			while ($scope.update_input.includes(",")){
				$scope.update_input = $scope.update_input.replace(",", "");
			}
			transactionFactory.create_transactions($scope.display_prep, function(data){
				if (data.error){
					console.log("Error uploading transactions: " + data.error);
				} else {
					console.log("New transactions uploaded.  Server response: " + JSON.stringify(data.result));
				}
			})
		}
		$scope.create_transaction = function(new_payment){ //on partial it is new_transaction.  Not sure why I chose to pass it in this way
			transactionFactory.create_transaction(new_payment, function(data){
				if (data.error){
					console.log('Error creating transaction: ' + data.error);
				} else {
					/*var used_date = $scope.new_transaction.date;
					used_date = new Date(used_date);
					if (used_date.getMonth() < 12){
						//console.log("About to add month");
						used_date.setMonth(used_date.getMonth() + 1); 
						//console.log("Added month: " + used_date);
					}
					$scope.$apply($scope.new_transaction.date = used_date.toLocaleDateString());*/
					$scope.saved_transaction = data.saved_transaction;
					if ($scope.retain_form_entries === false){
						for (this_key in $scope.new_transaction){
							$scope.new_transaction[this_key] = "";
						}
					}
					//console.log('Transaction created.');
				}
			})
		}
	}]);
	myApp.controller('unitsController', ['$scope', 'unitFactory', 'userFactory', function($scope, unitFactory, userFactory){
		unitFactory.index({populate: true}, function(these_units){
			if (these_units.error){
				console.log("Error retrieving unit index: " + these_units.error);
			} else {
				$scope.unit_index = these_units.index;
			}
		})
		$scope.create = function(new_unit){
			unitFactory.create(new_unit, function(new_index){
				if (new_index.error){
					console.log("Error creating unit: " + new_index.error);
				} else {
					$scope.unit_index = new_index.index;
					//console.log( "Unit created");
				}
			})
		}
		$scope.update = function(this_unit){
			unitFactory.update(this_unit, function(new_index){
				if (new_index.error){
					console.log("Error updating unit: " + new_index.error);

				} else {
					$scope.unit_index = new_index.index;
					//console.log( "Unit updated.");
				}
			})
		}
	}]);
			//for (z=0;z<this_new_history.dates.length;z++){
			//	this_new_history.dates[z] = new Date(this_new_history.dates[z]);
			//}
			//var these_balances = {
			//	dates: this_new_history.dates,
			//	values: this_new_history.values
			//};
			/*for (x=0;x<these_balances.length;x++){
				if (these_balances.values.length < 2000){
					these_balances.dates[0] = new Date("12/31/2006"); // some of them have transactions on 1/1/07 that I don't want collapsed into initial value.
					console.log("convert_to_daily is about to start iterating through " + these_balances.dates.length + " dates");
					for (y=1;y<these_balances.dates.length;y++){
						var this_date = new Date(these_balances.dates[y]);
						var this_value = these_balances.values[y];
						var last_date = new Date(these_balances.dates[y-1]);
						var last_value = these_balances.values[y-1];
						console.log("comparing " + this_date + " to " + last_date);
						if (this_date.getDate() === last_date.getDate()){					// if a date is repeated
							console.log("and decided they're the same date");
							these_balances.dates.splice(y-1, 1);		// only keep the last one.  Be careful of index shift though
							these_balances.values.splice(y-1, 1);
							y--;
						} else if (last_date.setDate(last_date.getDate() + 1) < this_date){	// remember that last_date is now +1
							these_balances.dates.splice(y, 0, last_date);
							these_balances.values.splice(y, 0, last_value);  // but do NOT put an extra y++, since you want to use this new insertion in next comparison
						}
					}
				}
			} */
			//$scope.this_new_history = this_new_history;
			//$scope.daily_result = these_balances;
	</script>
	<!--<script src="https://apis.google.com/js/platform.js?onload=init" async defer></script>
	<meta name="google-signin-client_id" content="544028406258-p756lflvl7dqrap03ajh3kogfmc873pf.apps.googleusercontent.com">-->
</head>
<body ng-app='myApp'>
 	<div ng-view></div>
</body>