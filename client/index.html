<!DOCTYPE HTML>
<html>
<head>
	<title>Wilana Calc</title>
	<link rel='stylesheet' type='text/css' href='./static/style.css'>
	<link rel='stylesheet' type='text/css' href='./static/LineChart.css'>
	<script type="text/javascript" src="./angular.js"></script>
	<script type="text/javascript" src="./angular-route-1_5_5.js"></script>
	<script type="text/javascript" src="./isaac.js"></script>
	<script type="text/javascript" src="./bcrypt.js"></script>
	<script type="text/javascript" src="./angular-animate.js"></script>
	<script type="text/javascript" src="./d3.js"></script>
	<script type="text/javascript" src="./LineChart.js"></script>
	<script>
	var myApp = angular.module("myApp", ['ngRoute', 'ngAnimate', 'n3-line-chart']);

	myApp.config(function($routeProvider){
		$routeProvider
			.when('/', {
				templateUrl: './partials/welcome.html'
			})
			.when('/login', {
				templateUrl: './partials/welcome.html'
			})
			.when('/matrix', {
				templateUrl: './partials/matrix_show.html'
			})
			.when('/reports', {
				templateUrl: './partials/reports.html'
			})
			.when('/transactions/new', {
				templateUrl: './partials/transactions_new.html'
			})
			.when('/transactions', {
				templateUrl: './partials/transactions_index.html'
			})
			.when('/units', {
				templateUrl: './partials/units_index_new_edit.html'
			})
			.when('/taxes', {
				templateUrl: './partials/taxes.html'
			})
			.when('/mortgage', {
				templateUrl: './partials/mortgage.html'
			})
			.when('/feedback', {
				templateUrl: './partials/feedback.html'
			})
			.when('/documents', {
				templateUrl: './partials/documents.html'
			})
			.when('/budget', {
				templateUrl: './partials/budget.html'
			})
			.when('/spending_history', {
				templateUrl: './partials/spending_history.html'
			})
			.when('/preferences', {
				templateUrl: './partials/preferences.html'
			})
			.when('/shareholder_accounts', {
				templateUrl: './partials/shareholder_accounts.html'
			})
			.otherwise({
				redirectTo: '/partials/welcome.html'
			});
	});
	myApp.factory('userFactory', ['$http', '$rootScope', function($http, $rootScope){
		/******** 
		USERFACTORY DOCS
		userFactory is the closest thing to an app-wide scope this app has.  It is designed to be injected into most or all controllers, since it is the place login status is managed client-side, and virtually every controller will need to check that.  As a result, it also can't generally have things injected into it, since Angular does not like circular injections.
		Main functions:
			1)  Have a record of user login status & admin privileges visible everywhere, so that server calls can be limited to tasks that actually require secure environments or db access.
			2)  Preload, make visible, & keep current & sorted (on client side) a list of all users, to simplify synchrony management of tasks that reference user lists.
			3)  Login, logout, registration, pw changes.
			4)  Serve as the primary controller for the nav pane, which means being the keeper of system messages to the user.  It is the place all other methods send error & task-result notifications to.  It displays them in the message log, and deletes the log at user request.
			6)  Could also be a good place for things like redirecting to the login page if someone tries to access views while logged out, & other tasks that would otherwise require lots of repetetive code on every view.

		Minor functions:
			1) Currently hosts the trigger for double-checking mongodb inter-model reference integrity, though that could probably be moved.
			2) (vestigial) hosts trigger for logging out all users at once for debug utiltity.  I should delete this.
		*********/
		console.log("loading userFactory");
		var factory = {};
		var this_seed = new Date();
		var these_milliseconds = this_seed.getTime();
		isaac.seed(these_milliseconds);
		var bcrypt = dcodeIO.bcrypt;
		bcrypt.setRandomFallback(isaac.prng);
		factory.message_log = [];
		factory.nav_topic = "";
		factory.current_user = false //in production, just use this for tasks that don't deal with secure information.
		factory.current_pw = "";
		factory.logged_in = "";
		factory.admin = false;
		factory.user_index = [];
		factory.index(function(preloaded_user_list){
			if (preloaded_user_list.error){
				userFactory.log('error', "Error retrieving user list: " + preloaded_user_list.error);
			} else {			
				factory.user_index = preloaded_user_list.users;
			}
		})
		factory.register = function(user_info, callback){			// register a new user.  If it works, update preloaded user list.  In any case, pass result on to controller.  For now I'm going to let controllers call userFactory.log where possible, so it takes no action for registration errors here.
			$http.post('/users/register', user_info).success(function(result){
				if (!result.error){
					factory.index(function(updated_user_list){
						if (updated_user_list.error){
							userFactory.log('error', "Error updating user list: " + updated_user_list.error);
						} else {			
							factory.user_index = updated_user_list.users;
						}
					})
				}
				callback(result);
			})
		}
		factory.login = function(credentials, callback){
			$http.post('/users/login', credentials).success(function(result){
				if (result.logged_in){
					factory.admin = result.admin;
					factory.logged_in = true;
					factory.current_user = result.unit;
					factory.current_pw = credentials.pw;
				}
				callback(result);
			})
		}
		factory.logout = function(unit, callback){
			$http.post('/users/logout', unit).success(function(result){
				if (result.logged_out === true){
					factory.current_user = false;
					factory.admin = false;
					factory.logged_in = false;
					factory.current_pw = "";
					$rootScope.$broadcast('logged_out');
					callback(result);
				}
			})
		}
		factory.update_user = function(updated_user, callback){
			updated_user.unit = factory.current_user;
			updated_user.online = true;
			var update_user_path = 'users/' + factory.current_user + '/update';
			$http.post(update_user_path, {updated_user: updated_user}).success(function(result){
				if (result.result){
					factory.current_pw = updated_user.pw_hash;
				}
				callback(result);
			})
		}
		factory.index = function(callback){
			$http.post('/users').success(function(data){
				data.users.sort(function(a,b){
					if (a.unit == "Admin"){
						return 1;
					} else if (b.unit == "Admin"){
						return -1;
					} else {
						return (Number(a.unit) - Number(b.unit));
					}
				})
				callback(data);
			})
		}
		factory.log = function(action, message){  // can take 3 styles & numbers of arguments.  To add a message: ('error' or 'message' (whichever is relevant), message text).  to clear: ('clear').  to just retrieve log: ().
			if ((action === 'error' || action === 'message') && (typeof message === "string")){
				factory.message_log.unshift({type: action, date: (new Date(Date.now()).toLocaleTimeString()), text: message});
			} else if (action === 'clear'){
				console.log('Clearing message log');
				for (i=0; i<factory.message_log.length+1;i++){
					factory.message_log.shift();
				}
			}
			return factory.message_log;
		}
		return factory;
	}]);
	myApp.factory('expenditureFactory', ['$http', function($http){
		var factory = {};
		factory.index = function(callback){
			$http.post('/budget_lines').success(function(new_index){
				console.log("factory received new spending history index: " + JSON.stringify(new_index));
				var expenses_by_supercategory = {"Expense Totals": {}, "Taxes": {}, "Mortgage": {"Total": {}}, "Insurance": {}, "Utilities": {}, "Other": {}, "Maintenance": {"Total": {}}, "Income": {"Total": {}}};
				var supercategory_key = {"Sewer": "Utilities", "Gas": "Utilities", "Garbage": "Utilities", "Water": "Utilities", "Electricity": "Utilities", "Water Meter": "Utilities", "Property Tax": "Taxes", "Income Tax": "Taxes", "Sr Citizen Prop Tax Refund": "Taxes", "Mortgage Principal": "Mortgage", "Mortgage Interest": "Mortgage", "Building Insurance": "Insurance"};
				var add_to_total = function(category_values, supercategory){
					if ("Total" in expenses_by_supercategory[supercategory]){
						for (this_year in category_values){
							if (expenses_by_supercategory[supercategory].Total[this_year]){
								expenses_by_supercategory[supercategory].Total[this_year] += category_values[this_year];
								if (supercategory === "Income"){
									console.log("Added to income totals: " + expenses_by_supercategory[supercategory].Total);
								}
							} else {
								expenses_by_supercategory[supercategory].Total[this_year] = category_values[this_year];
								if (supercategory === "Income"){
									console.log("Initialized income totals: " + expenses_by_supercategory[supercategory].Total);
								}
							}
						}
					} else if (supercategory === "Expense Totals"){
						for (this_year in category_values){
							if (expenses_by_supercategory[supercategory][this_year]){
								expenses_by_supercategory[supercategory][this_year] += category_values[this_year];
							} else {
								expenses_by_supercategory[supercategory][this_year] = category_values[this_year];
							}
						}
					}
				}		
				var index_for_chart = {income_categories: {}, expense_categories: {}};
				for (i=0;i<new_index.new_index.length;i++){
					var this_category = new_index.new_index[i];
					console.log("this_category is " + JSON.stringify(this_category));
					if (this_category.is_income === true){
						index_for_chart.income_categories[this_category.category] = [];
						if (this_category.values){
							for (year in this_category.values){
								index_for_chart.income_categories[this_category.category].push({"year": year, "amount": this_category.values[year]});
							}
							console.log(JSON.stringify(this_category) + " is being treated as income");
							expenses_by_supercategory.Income[this_category.category] = this_category.values;
							add_to_total(this_category.values, "Income");
						}
					} else {
						index_for_chart.expense_categories[this_category.category] = [];
						if (this_category.values){
							for (year in this_category.values){
								index_for_chart.expense_categories[this_category.category].push({"year": year, "amount": this_category.values[year]});
							}
							add_to_total(this_category.values, "Expense Totals");
							if (this_category.is_maintenance === true){
								expenses_by_supercategory.Maintenance[this_category.category] = this_category.values;
								add_to_total(this_category.values, "Maintenance");
							} else if (supercategory_key[this_category.category]){
								expenses_by_supercategory[supercategory_key[this_category.category]][this_category.category] = this_category.values;
								add_to_total(this_category.values, supercategory_key[this_category.category]);
							}
						} else {
							if (this_category.values){
								expenses_by_supercategory.Other[this_category.category] = this_category.values;
							}
						}
					}
				}
				new_index.by_supercategory = expenses_by_supercategory;
				new_index.index_for_chart = index_for_chart;
				console.log("Index reformatted and being returned as new_index.by_supercategory: " + JSON.stringify(new_index.by_supercategory));
				console.log("Returning new index_for_chart:                   " + JSON.stringify(new_index.index_for_chart));
				callback(new_index);
			})
		}
		factory.create_budget_line = function(this_new_line, callback){
			$http.post('/budget_lines/create', {new_category: this_new_line}).success(function(created_category){
				console.log("factory received save budget category: " + created_category);
				factory.index(function(new_index){
					callback(new_index);
				})
			})
		}
		return factory;
	}])
	myApp.factory('filterFactory', ['$rootScope', function($rootScope){
		var factory = {};
		var filters = {};
		var filter_types = {};
		var isEmpty = function(this_object) { 
   			for (var x in this_object) { 
   				return false; 
   			}
   			return true;
   		}
   		var broadcast_prep = function(action, this_filter, this_value, callback){
   			if (action === "add"){
   				filters[this_filter][this_value] = true;  //couldn't think of a way to add to hash if present or create hash if absent without at least one if statement
				factory.filter_count += 1;
				console.log('filter ' + this_filter + ": " + this_value + " added to filter hash and filter_count is now " + factory.filter_count);
   			} else if (action === 'remove'){
				delete filters[this_filter][this_value];
				factory.filter_count -= 1;
				console.log('filter ' + this_filter + ": " + this_value + " removed.");
   			}
   			callback(factory.filter_count);
   		}
   		factory.filter_count = 0;
   		factory.get = function(this_filter){
   			if (isEmpty(filters[this_filter])){
   				console.log("determined that " + this_filter + " in " + JSON.stringify(filters) + " is empty");
   				return false;
   			} else {
   				console.log("Returning populated filter: " + JSON.stringify(filters[this_filter]));
   				return filters[this_filter];
   			}
   		}
		factory.add_filter = function(this_filter, this_value){
			if (!(this_filter in filters)){
				console.log("filterfactory is adding " + this_filter + " to " + JSON.stringify(filters));
				filters[this_filter] = {};
			}
			console.log("About to start broadcast prep by adding" + this_value + ": true to " + this_filter + " in " + JSON.stringify(filters));
			broadcast_prep("add", this_filter, this_value, function(filter_count){
				console.log("In broadcast_prep callback.  filter_count is " + filter_count + " About to broadcast & return filter values.");
				$rootScope.$broadcast('filter_updated');  // this was firing off and causing a transaction list update bfore filter_count could get incremented, so turned it into callback.
			})
			console.log("add_filter is returning " + this_filter);
			return factory.get(this_filter);
		}
		factory.remove_filter = function(this_filter, this_value){
			broadcast_prep("remove", this_filter, this_value, function(filter_count){
				console.log("In broadcast_prep callback.  filter_count is " + filter_count + "About to broadcast & return filter values or false");
				$rootScope.$broadcast('filter_updated');
				return factory.get(this_filter);
			})
		}
		return factory;
	}]);
	myApp.filter('in_group', function(){
		console.log("ingroup filter called");
		return function(parameters){   // parameters = {item_list: [x,y,z], group: [x,y]}  or {item_list: [{object}, {object}], group: {value: true, value: true}, property: 'unit_number'}
			var filtered_list = [];
			if (!parameters.group){
				//console.log("Filter determined that there is no group, which would be the case if group were false.  Item List would have been " + parameters.item_list + " long.");
				filtered_list = parameters.item_list;		// 2nd parameter will be "group: false" if that property is set to be unfiltered.  This is different from having no filters clicked, which would return []
			} else {
				for (i=0;i<parameters.item_list.length;i++){
					if (!parameters.property){ // determines whether the input list is a regular array or an array of objects
						//console.log("Filter is behaving as if it were given a list of items to filter instead of an object of them");
						if (parameters.item_list[i] in parameters.group){
							//console.log("Determined that parameters item list i: " + parameters.item_list[i] + " is in parameters group: " + parameters.group);
							filtered_list.push(parameters.item_list[i]);
						} else {
							//console.log("Filter did not think this item was 'in' this group & so culled it.  Group: " + parameters.group + ", Item: " + JSON.stringify(parameters.item_list[i]));
						}
					} else {
						//console.log("filter is behaving as if it were given an object full of things to evaluate, not a list");
						if (parameters.item_list[i][parameters.property] in parameters.group){
							filtered_list.push(parameters.item_list[i]);
						} else {
							console.log("Filter determined that tem list [i]." + parameters.property + ", " + parameters.item_list[i][parameters.property] + " was not in " + JSON.stringify(parameters.group) + " and threw it away");
						}
					}
				}
			}
			console.log("filter is returning filtered_list, length " + filtered_list.length);
			return filtered_list;
		}
	});
	myApp.factory('matrixFactory', ['$http', 'unitFactory', 'userFactory', function($http, unitFactory, userFactory){
		/*********
		MATRIXFACTORY DOCS
		Main tasks: 
			1) Preload a 2-dimensional array of all dues values for all units for all months, since that isn't terribly sensitive inforrmation and will simplify synchrony management.   ****** Still needs implementation
			2) Be able to supply other app elements with unit- and time-specific slices of that dues matrix.   ***** This is currently not centralized and gets done by other factories.
			3) Be able to supply a version of the dues matrix in transaction list format.
			4) Host the master copy of the Initial Date.
		**************/
		console.log("loading matrixFactory");
		var factory = {};
		var initial_date = new Date('01/01/2011');
		var today = new Date();
		var months_to_date = (today.getFullYear() - 2011) * 12 + today.getMonth() + 1;
		var this_index = function(){
			var start_index = -1;
			var bump = function(bump_or_tell){
				if (bump_or_tell == "bump"){
					return(start_index += 1);
				} else if (bump_or_tell == "tell"){
					return (start_index);
				}
			}
			return bump;  //remember:  "this_index" now contains the ****function**** bump, not its result. So this_index actually does take an argument. 
		}();
		var transactionify = function(dues_list, unit_number){
			var date_counter = new Date('01/01/2011');
			var transactionified = [];
			for (dues_index=0;dues_index<dues_list.length;dues_index++){
				transactionified[dues_index] = {"_unit": {number: unit_number}, "date": new Date(date_counter.setMonth(date_counter.getMonth() + 1)), "amount": (dues_list[dues_index] * 100), "type": "dues", "notes": "", };
			}
			return transactionified;
		}
		factory.dues_as_transactions = [];
		factory.transactionified_dues_index = function(callback){
			console.log("about to transactionify dues for units " + unitFactory.unit_numbers);
			for(i=0;i<unitFactory.unit_numbers.length;i++){
				$http.post('/trim_matrix', {unit: unitFactory.unit_numbers[this_index('bump')], months: months_to_date}).success(function(matrix_result){
					if (matrix_result.error){
						userFactory.log({"error": matrix_result.error});
					} else {
						factory.dues_as_transactions = factory.dues_as_transactions.concat(transactionify(matrix_result.dues_list, matrix_result.unit));
						//console.log("Added a unit's dues to dues_as_transactions.  First is " + JSON.stringify(factory.dues_as_transactions[0])+ " and #" + factory.dues_as_transactions.length + " is " + JSON.stringify(factory.dues_as_transactions[factory.dues_as_transactions.length - 1]));
					}
					if (this_index('tell') === unitFactory.unit_numbers.length - 1){
						//console.log("Done transactionifying dues for " + (this_index('tell') + 1) + "units.");
						callback(factory.dues_as_transactions);
					}
				})
			}
		}
		factory.count_months = function(bounds){  // parameter should be in form {start_date: X, end_date: Y}  returns the number of full (& partial!!) months from one date to the next.  Remember to subtract 1 if you only want full months & days aren't identical.
			if (bounds){
				if (!bounds.start_date){
					bounds.start_date = new Date(initial_date);
				} else {
					bounds.start_date = new Date(bounds.start_date);
				}
				if (!bounds.end_date){
					bounds.end_date = new Date();
				} else {
					bounds.end_date = new Date(bounds.end_date);
				}
			} else {
				bounds = {start_date: new Date(initial_date), end_date: new Date()};
			}
			var count_month_result = {count: 0, labels: []};
			var this_month = new Date(bounds.start_date);
			while (this_month < bounds.end_date){
				count_month_result.labels[count_month_result.count] = this_month;  //ensures that .count is number of slots in .labels
				this_month = new Date(bounds.start_date.setMonth(bounds.start_date.getMonth() + 1));  //note that this changes both this_month and bounds.start_date.  Important for when it iterates.
				count_month_result.count += 1;
			}
			return count_month_result;
		}
		factory.index = function(callback){
			var month_count = factory.count_months();
			$http.post('/dues_matrixes', {months: month_count.count}).success(function(data){
				var formatted_data = {};
				if (data.error){
					formatted_data = data;
				} else {
					for (i=0; i<data.rates.length; i++){  //iterates over every unit and assigns whole rows of dues at a time
						if (data.rates[i][0] != null){
							formatted_data[i] = {'highlight': false, 'rates': data.rates[i]};  //reformats matrix as {1: {highlight: false, rates: [320,null,null,335...], {2: {highlight: false, rates: [320,null,null,335...]} for ng-repeat
						}
					}
				}
				callback(formatted_data);
			})
		};
		return factory;
	}]);
	myApp.factory('mortgageFactory', ['$http', function($http){
		var factory = {};
		var add_running_balances = function(raw_mortgages){
			console.log("raw_mortgages: " + JSON.stringify(raw_mortgages));
			if (!Array.isArray(raw_mortgages)){ //takes either a single mortgage or array of mortgages, adds a running balance column, and returns it as an areray for easy ng-repeating;
				raw_mortgages = [raw_mortgages];
			}
			//console.log("raw_mortgages: " + JSON.stringify(raw_mortgages));
				for (i=0;i<raw_mortgages.length;i++){
				raw_mortgages[i].running_balances = [];
				raw_mortgages[i].initial_date = new Date(raw_mortgages[i].initial_date);
				//console.log("raw_mortgages: " + JSON.stringify(raw_mortgages));
				//console.log("Raw_mortgages[i].payments: " + raw_mortgages[i].payments);
				for (payment_index=0;payment_index<raw_mortgages[i].payments.length;payment_index++){
					if (payment_index === 0){
						raw_mortgages[i].running_balances.push(raw_mortgages[i].initial_balance - raw_mortgages[i].payments[0].principal);
						raw_mortgages[i].payments[payment_index].pay_date = new Date(raw_mortgages[i].payments[payment_index].pay_date);
						//console.log("Pushed initial running balance which was the difference of " + raw_mortgages[i].initial_balance + " and " + raw_mortgages[i].payments[0].principal + " which is " + (raw_mortgages[i].initial_balance - raw_mortgages[i].payments[0].principal));
					} else {
						raw_mortgages[i].running_balances.push(raw_mortgages[i].running_balances[payment_index-1] - raw_mortgages[i].payments[payment_index].principal);
						raw_mortgages[i].payments[payment_index].pay_date = new Date(raw_mortgages[i].payments[payment_index].pay_date);
						//console.log("Pushed an additional running balance which was the difference of " + raw_mortgages[i].running_balances[payment_index-1] + " and " + raw_mortgages[i].payments[payment_index].principal + " which is " + (raw_mortgages[i].running_balances[payment_index-1] - raw_mortgages[i].payments[payment_index].principal));
					}
					if (i === raw_mortgages.length - 1 && payment_index === raw_mortgages[i].payments.length-1){
						//console.log("Done iterating over payments.  Made these running balances: " + raw_mortgages[i].running_balances);
						console.log("add_running_balances is returning " + JSON.stringify(raw_mortgages));
						return raw_mortgages;
					}
				}
			}
		}
		factory.create_mortgage = function(new_mortgage, callback){
			delete new_mortgage.running_balances;
			//console.log("Factory is sending " + JSON.stringify(new_mortgage) + " for creation");
			$http.post("/mortgages/create", new_mortgage).success(function(data){
				//console.log("Back in factory, sending " + JSON.stringify(data) + " to scope");
				callback(data);
			})
		}
		factory.mortgage_index = function(callback){
			$http.get("/mortgages").success(function(data){
				//console.log("Factory received from server: " + JSON.stringify(data));
				if (data.mortgage_index){		//initial date is just verifying that at least one 
					data.these_complete_mortgages = add_running_balances(data.mortgage_index);
				}
				callback(data);
			})
		}
		return factory;
	}]);
	myApp.factory('propertyTaxFactory', ['$http', function($http){
		var factory = {};
		factory.index = function(callback){
			$http.post('/property_taxes').success(function(result){
				if (result.error){
					callback(result);
				} else {
					var tax_year_keys = ["year_paid", "total", "bill_main", "land_val_main", "imp_val_main", "units_main", "per share", "tax_by_size", "bill_alt", "land_val_alt", "imp_val_alt", "units_alt", "unit_size_shares", "unit_size_numbers", "Actions"];
					var grouped_by_attribute = {};
					var tax_by_size = {"small": [], "medium": [], "large": []};
					for (attribute_index=0;attribute_index<tax_year_keys.length;attribute_index++){ //use first entry to figure out number of attributes per tax year & iterate that many times.
						var attribute_data = [];
						for (year_index=0;year_index<result.prop_tax_index.length;year_index++){
							if (tax_year_keys[attribute_index] === "Actions"){
								attribute_data.push(result.prop_tax_index[year_index]._id);
							} else if (tax_year_keys[attribute_index] === "total"){
								attribute_data.push(result.prop_tax_index[year_index].bill_main + result.prop_tax_index[year_index].bill_alt);
							} else if (tax_year_keys[attribute_index] === "units_main"){
								if (result.prop_tax_index[year_index]["units_main"]["small"].indexOf(3) === -1){
									attribute_data.push("No");
								} else {
									attribute_data.push("Yes");
								}
							} else if (tax_year_keys[attribute_index] === "per share"){
								var unit_sizes = ["small", "medium", "large"];
								var total_main_shares = 0;
								for (size_index in unit_sizes){
									total_main_shares += (result.prop_tax_index[year_index].unit_size_shares[unit_sizes[size_index]] * result.prop_tax_index[year_index].units_main[unit_sizes[size_index]].length);  //# of units per size * # shares per size, iterated over 3 sizes
								}
								attribute_data.push(result.prop_tax_index[year_index].bill_main / total_main_shares);
							} else if (tax_year_keys[attribute_index] === "tax_by_size"){
								var this_datum = {};
								for (size_index in unit_sizes){
									tax_by_size[unit_sizes[size_index]].push(result.prop_tax_index[year_index].unit_size_shares[unit_sizes[size_index]] * grouped_by_attribute["per share"][year_index]);
								}
							} else {
								attribute_data.push(JSON.stringify(result.prop_tax_index[year_index][tax_year_keys[attribute_index]]));
							}
						}
						grouped_by_attribute[tax_year_keys[attribute_index]] = attribute_data;
					}
					var index_by_attribute = {};
					index_by_attribute = {
						"Year Paid": grouped_by_attribute.year_paid,
						"Total Tax": grouped_by_attribute.total,
						"Primary Bill": grouped_by_attribute.bill_main,
						"Unit 3 occupied?": grouped_by_attribute.units_main,
						"Sr. Citizen Bill": grouped_by_attribute.bill_alt,
						"Tax per share": grouped_by_attribute['per share'],
						"Tax per small unit": tax_by_size["small"],
						"Tax per medium unit": tax_by_size["medium"],
						"Tax per large unit": tax_by_size["large"],
						"Actions": grouped_by_attribute.Actions
					};
					console.log("constructed this index_by_attribute: " + JSON.stringify(index_by_attribute));
					callback({prop_tax_index: result.prop_tax_index, grouped_by_attribute: grouped_by_attribute, index_by_attribute: index_by_attribute});
				}
			})
		}
		factory.create_tax = function(tax_info, callback){
			$http.post('/property_taxes/create', tax_info).success(function(result){
				if (result.error){
					callback(result);
				} else {
					factory.index(function(updated_index){
						callback(updated_index);
					})
				}
			})
		}
		factory.delete_tax = function(bad_tax_id, callback){
			var delete_path = "/property_taxes/" + bad_tax_id + "/delete";
			$http.post(delete_path).success(function(result){
				if (result.error){
					callback(result);
				} else {
					factory.index(function(updated_index){
						callback(updated_index);
					})
				}
			})
		}
		return factory;
	}]);
	myApp.factory('reportFactory', ['$http', '$filter', 'filterFactory', 'matrixFactory', 'unitFactory', 'transactionFactory', 'userFactory', function($http, $filter, filterFactory, matrixFactory, unitFactory, transactionFactory, userFactory){
		var factory = {};
		var transaction_index = [];
		var transified_dues_index = [];
		var all_dues = [];
		var sum_transactions = function(transaction_list){
			console.log("reportFactory sum_transactions called with list of length " + transaction_list.length);
			var sum = 0;
			var running_balances = [];
			for (this_index=0;this_index<transaction_list.length;this_index++){
				if (transaction_list[this_index].type === "credit"){
					sum += transaction_list[this_index].amount;
					running_balances.push(sum);
				} else {
					sum -= transaction_list[this_index].amount;
					running_balances.push(sum);
				}
			}
			console.log("its sum is " + sum);
			return {sum: sum, running_balances: running_balances};
		}
		factory.filtered_transactions = [];

		transactionFactory.index(function(data){
			console.log("Performing transaction index");
			transaction_index = data.index;
			matrixFactory.transactionified_dues_index(function(trans_dues_list){
				//console.log("received transactionified dues list: " + JSON.stringify(trans_dues_list));
				transified_dues_index = trans_dues_list;
			})
		})
		var re_filter = function(transaction_list){
				console.log("In re_filter, starting with index size " + transaction_list.length + ".  Query will be: $filter('in_group')({'item_list':" + transaction_list + ", 'group': " + filterFactory.get('unit') + ", 'property': 'unit'}); ");
				var once_filtered = $filter('in_group')({'item_list': transaction_list, 'group': filterFactory.get('unit'), 'property': 'unit'}); 
				console.log("once_filtered has been reduced to " + once_filtered.length + " & will now be filtered by " + filterFactory.get('type'));
				var re_filtered_transactions = $filter('in_group')({'item_list': once_filtered, 'group': filterFactory.get('type'), 'property': 'type'});
				return re_filtered_transactions;
		}
		factory.reference_health = function(callback){
			var runaway_transactions = [];
			var rejecting_units = [];
			transactionFactory.index(function(trans_data){
				var sick_transaction_list = trans_data.index;
				unitFactory.index({populate: false}, function(unit_data){
					var sick_unit_list = unit_data.index;
					console.log("Commencing reference check on " + sick_unit_list.length + " units and " + sick_transaction_list.length + " transactions.");
					var comparison_count = 0;
					var this_unit = {};
					var this_transaction = {};
					for (var unit_index = 0;unit_index<sick_unit_list.length;unit_index++){
						for (var trans_index=0; trans_index<sick_transaction_list.length; trans_index++){
							comparison_count++;
							this_unit = sick_unit_list[unit_index];
							this_transaction = sick_transaction_list[trans_index];
							if (this_transaction._unit._id === this_unit._id){ // if this transaction thinks it has found its mother unit
								if (this_unit.transactions.indexOf(this_transaction._id) === (-1)){ //but the mother thinks it's a stranger
									rejecting_units.push({"unit": this_unit, "transaction": this_transaction});
								}
							}
							if (this_unit.transactions.indexOf(this_transaction._id) != (-1)){ // if this trans is on the unit's trans list
								if (this_transaction._unit._id != this_unit._id){ // but the transaction thinks it belongs elsewhere
									runaway_transactions.push({"transaction": this_transaction, "unit_number": this_unit.number});
								}
							}
						}
					}
					console.log("Finished " + comparison_count + "comparisons of " + sick_unit_list.length + " units and " + sick_transaction_list.length + " transactions. About to return report");
					if (runaway_transactions.length + rejecting_units.length === 0){
						callback("ok");
					} else {
						callback({runaway_transactions: runaway_transactions, rejecting_units: rejecting_units});
					}
				});
			});
		};
		factory.update_report = function(reason, callback){
			console.log("reportFactory update_report called.  About to combine " + transaction_index.length + " transactions with " + transified_dues_index.length + " dues values");
			var transactions_and_dues_index = transaction_index.concat(transified_dues_index);  //this still needs its amounts /100 I think.
			var factory_response = {};
			if (filterFactory.filter_count > 0){
				console.log("update_report decided are enough active filters: " + filterFactory.filters_active + " to continue processing update");
				if (reason === "transaction_change"){
					transactionFactory.index(function(data){
						if (data === false){
							//console.log("update_report got the idea that new index data is false.  I have no idea why it even checks");;
							callback([]);
						} else if (data.index){
							transactions_and_dues_index = (data.index).concat(transified_dues_index);
							console.log("reportFactory retrieved new base transaction_list after receiving notice of change. length: " + transactions_and_dues_index.length);
							factory.filtered_transactions = re_filter(transactions_and_dues_index);
							if (factory.filtered_transactions.length > 500){
								factory_response.message = String(factory.filtered_transactions.length) + " transactions meet your filter criteria.  Please modify your filters to be more restrictive.  Results will display once they number less than 500.";
							} else {
								factory_response.sums = sum_transactions(factory.filtered_transactions);
								factory_response.sums.sum = (factory_response.sums.sum / 100).toFixed(2);
								factory_response.filtered_transactions = factory.filtered_transactions;
							}
						}
						callback(factory_response);
					})
				} else {
					console.log("Decided only a re-filter was necessary");
					factory.filtered_transactions = re_filter(transactions_and_dues_index);
					if (factory.filtered_transactions.length > 2000){
						factory_response.message = String(factory.filtered_transactions.length) + " transactions meet your filter criteria.  Please modify your filters to be more restrictive.  Results will display once they number less than 2000.";
					} else {
						factory_response.sums = sum_transactions(factory.filtered_transactions);
						factory_response.sums.sum = (factory_response.sums.sum / 100).toFixed(2);
						console.log("factory_response sums: " + JSON.stringify(factory_response.sums));
						factory_response.filtered_transactions = factory.filtered_transactions;
					}
					callback(factory_response);
				}
			} else {
				console.log("update_report decided there are no active filters and so returned an empty list");
				factory_response.filtered_transactions = [];
				callback(factory_response);
			}

		}
		factory.balance_summary = function(callback){
			var these_units = unitFactory.unit_numbers;
			var these_balances = {};
			for(i=0; i<these_units.length;i++){									//go through each one
				factory.full_history(these_units[i], function(this_history){	//and determine its balance
					these_balances[this_history.unit] = this_history.current_balance; //and add the balance to the index hash
					if (Object.keys(these_balances).length === these_units.length){  //and if we have as many balances as units, that means we're done, and should callback the result.
						callback(these_balances);
					}
				})
			}
		}
		/*factory.balance_summary = function(callback){
			unitFactory.numbers_index(function(unit_numbers_index){						 // get all unit numbers
				if (unit_numbers_index.error){
					callback(unit_numbers_index);
				} else {
					var these_units = unit_numbers_index.unit_numbers;
					var these_balances = {};
					for(i=0; i<these_units.length;i++){									//go through each one
						factory.full_history(these_units[i], function(this_history){	//and determine its balance
							these_balances[this_history.unit] = this_history.current_balance; //and add the balance to the index hash
							//console.log("added a unit to balance summary.  Summary now has " + Object.keys(these_balances).length + " units.  Object: " + JSON.stringify(these_balances));
							if (Object.keys(these_balances).length === unit_numbers_index.unit_numbers.length){  //and if we have as many balances as units, that means we're done, and should callback the result.
								//console.log("returning balance summary to controller");
								callback(these_balances);
							} else {
								//console.log("Chose not to return summary of length " + Object.keys(these_balances).length + " because it is less than " + unit_numbers_index.unit_numbers.length);
							}
						})
					}
				}
			})
		}*/
		factory.full_history = function(unit, callback){
			var today = new Date();
			var months = (today.getFullYear() - 2011) * 12 + today.getMonth() + 1;
			var show_route = '/units/' + unit;
			var this_full_history = {transactions: [], balances: []};
			$http.post('/trim_matrix', {unit: unit, months: months}).success(function(matrix_result){
				//console.log("In trim-matrix callback in full_history method");
				var these_dues = [];
				var these_payments = [];
				var these_assessments = [];
				var these_fees = [];
				var dues_date = new Date('12/01/2010');
				for (i=0; i<matrix_result.dues_list.length; i++){
					these_dues.push({date: dues_date.setMonth(dues_date.getMonth() + 1), amount: matrix_result.dues_list[i], type: "dues"})
				}
				$http.post(show_route).success(function(unit_result){
					//console.log("In units/show callback in full_history method: " + JSON.stringify(unit_result));
					these_transactions = unit_result.unit.transactions;
					for (i=0; i<these_transactions.length; i++){
						these_transactions[i].amount = (these_transactions[i].amount / 100);
					}
					var this_history = these_dues.concat(these_transactions);
					for(i=0; i<this_history.length; i++){
						this_history[i].date = new Date(this_history[i].date);
						this_history[i].date = this_history[i].date.toLocaleDateString();
					}
					this_history.sort(function(a,b){return new Date(a.date) - new Date(b.date)});
					var previous_balance = unit_result.unit.initial_balance;
					for(i=0; i<this_history.length; i++){
						if (this_history[i].type === 'credit'){
							this_history[i].credit_amount = (this_history[i].amount).toFixed(2);
							this_history[i].charge_amount = "";
							previous_balance += Number(this_history[i].amount);
						} else {
							this_history[i].charge_amount = (this_history[i].amount).toFixed(2);
							this_history[i].credit_amount = "";
							previous_balance -= Number(this_history[i].amount);
						}
						this_full_history['balances'].push(previous_balance.toFixed(2));
						this_full_history['transactions'].push(this_history[i]);
					}
					this_full_history['balances'].reverse();
					this_full_history['transactions'].reverse();
					callback({unit: unit, full_history: this_full_history, current_balance: this_full_history['balances'][0], initial_balance: unit_result.unit.initial_balance.toFixed(2)});
				})
			})
		}
		return factory;
	}]);
	myApp.factory('transactionFactory', ['$http', function($http){
		var factory = {};
		factory.allowed_types = ['credit', 'assessment', 'late_fee', 'other_fee', 'dues'];
		factory.index = function(callback){
			$http.post("/transactions").success(function(data){
				var index_by_unit = {};
				for (i=0;i<data.index.length;i++){
					var this_transaction = data.index[i];
					this_transaction.unit = this_transaction._unit.number;
					var this_unit = String(this_transaction._unit.number);
					//console.log("this transaction.date is a " + (typeof this_transaction.date) + " and contains " + this_transaction.date);
					this_transaction.date = new Date(this_transaction.date);
					//console.log("the new improved date: " + this_transaction.date);
					if (!index_by_unit[this_unit]){
						index_by_unit[this_unit] = [];
					}
					index_by_unit[this_unit].push(this_transaction);
				}
				callback({index: data.index, index_by_unit: index_by_unit});
			})
		}
		factory.create_transactions = function(credit_chart, callback){  //see update_dues partial for formatting instructions
			var transaction_count = 0;
			var row_index = function(){
				var start_index = 0;
				var bump = function(bump_or_tell){
					if (bump_or_tell == "bump"){
						return(start_index += 1);
					} else if (bump_or_tell == "tell"){
						return (start_index);
					}
				}
				return bump;
			}();
			for(row=1; row<credit_chart.length; row++){					
				var date_list_for_chopping = [];
				for (date_index=0; date_index < credit_chart[0].length; date_index++){  //if I just say chopping = creditchart0, it passes by reference.
					date_list_for_chopping.push(credit_chart[0][date_index]);
				}
				for(col=1; col<credit_chart[row].length; col++){
					var this_amount = Number(credit_chart[row][col]);
					credit_chart[row][col] = {amount: this_amount, date: date_list_for_chopping[col], _unit: credit_chart[row][0], type: "credit", check_number: "", notes: ""};
					if (credit_chart[row][col].amount === 0 || !credit_chart[row][col].amount){
						credit_chart[row].splice(col, 1);
						date_list_for_chopping.splice(col, 1);
						console.log("Spliced out credit_chart coordinates " + row + ", " + col);
						col -= 1;
					}
				}
				transaction_count += credit_chart[row].length - 1;
				$http.post('/transactions/createMany', {credit_row: credit_chart[row_index("bump")]}).success(function(data){
					callback(data);
				})
			}
			console.log("# transactions: " + transaction_count);
		}
		factory.create_transaction = function(new_transaction, callback){
			$http.post('/transactions/createOne', {new_transaction: new_transaction}).success(function(data){
				callback(data);
			})
		}
		factory.update = function(updated_transaction, callback){
			var update_path = "/transactions/" + updated_transaction._id + "/update";
			//delete updated_transaction.unit;
			//delete updated_transaction._id;
			$http.post(update_path, {updated_transaction: updated_transaction}).success(function(data){
				console.log("Factory received what should be updated transaction from server: " + JSON.stringify(data));
				callback(data);
			})
		}
		factory.delete_one = function(id, callback){
			var delete_path = "/transactions/" + id + "/delete";
			$http.post(delete_path).success(function(result){
				callback(result);
			})
		}
		factory.delete_all = function(callback){
			$http.post("/transactions/deleteMany").success(function(result){
				callback(result);
			})
		}
		factory.date_for_sorting = function(transaction){
			var this_date = new Date(transaction.date);
			return this_date;
		}
		return factory;
	}]);
	myApp.factory('unitFactory', ['$http', 'userFactory', function($http, userFactory){
		/*************
		UNITFACTORY DOCS
		This is another high-end factory due to many scopes & factories needing access to a unit number list, though it is still one step below userFactory.
		Main Tasks:
		1)  Preload a list of unit numbers in the building, and make it visible everywhere to simplify synchrony management.
		2)  NOT preload a list of entire unit models, which could expose private information.
		3)  Call server for queries about deposit status and other unit traits that might pop up in the future.
		4)  Call server to populate unit profile index, though I'm using this view less & less in favor of trait-specific views.
		5)  Maintain rarely-used ability to update units (shareholder & deposit changes mainly);
		Minor tasks:
		1)  (vestigial) Ability to create new units.  Keep for now since it was a fair amount of work on the html side to make the form.
		*************/
		console.log("loading unitFactory");
		var factory = {};
		factory.unit_numbers = []; 	// is just a raw list of numbers.  no IDs or objects.  If you want a list with "Admin", go to userfactory
		$http.get('/unit_numbers_index').success(function(data){ //this is intended to replace factory.numbers_index by pre-loading unit numbers & simplifying asynchrony
			if (data.error){
				userFactory.log({error: data.error});
			} else {
				for (i=0; i<data.unit_numbers.length; i++){
					factory.unit_numbers.push(data.unit_numbers[i].number);  // the raw server feedback contains _ids that don't need to be public.
				}
			}
		});
		factory.numbers_index = function(callback){
			$http.get('/unit_numbers_index').success(function(data){
				if (data.error){
					callback({error: data.error});
				} else {
					var unit_numbers = [];
					for (i=0; i<data.unit_numbers.length; i++){
						unit_numbers.push(data.unit_numbers[i].number);
					}
					callback({unit_numbers: unit_numbers}); // is just a raw list of numbers.  no IDs or objects.
				}
			});
		}
		factory.index = function(options, callback){ // options is currently either {populate: true/false} or {deposits: true/false}
			$http.post('/units', {options: options, credentials: {unit: userFactory.current_user, pw: userFactory.current_pw}}).success(function(data){
				data.deposit_index = {};
				if (data.index){
					for (i=0; i<data.index.length; i++){
						if (options.deposits){
							data.deposit_index[data.index[i].number] = {"pet_deposit": data.index[i].pet_deposit, "sublease_deposit": data.index[i].sublease_deposit};
						} else {
							data.index[i].initial_balance_string = data.index[i].initial_balance.toFixed(2);					
						}
					}
				}
				callback(data);
			});
		}
		factory.create = function(new_unit, callback){
			$http.post('/units/create', new_unit).success(function(data){
				if (data.error){
					callback(data);
				} else {
					factory.index(function(these_units){
						callback(these_units);
					})
				}
			});
		}
		factory.update = function(updated_unit, callback){
			var update_path = '/units/'+updated_unit._id+'/update'
			$http.post(update_path, updated_unit).success(function(data){
				if (data.error){
					callback(data);
				} else {
					factory.index(function(these_units){
						callback(these_units);
					})
				}
			});
		}
		return factory;
	}]);
	
	myApp.controller('appController', ['$scope', '$rootScope', '$location', 'userFactory', 'reportFactory', 'transactionFactory', function($scope, $rootScope, $location, userFactory, reportFactory, transactionFactory){	
		console.log("loading appController");
		$scope.current_user = userFactory.current_user;
		$scope.logged_in = userFactory.logged_in;
		$scope.admin = userFactory.admin;

		if (!$scope.logged_in){
			$location.url("/login");
		}
		$scope.logout_result = "";
		$scope.nav_topic = userFactory.nav_topic;
		$scope.this_view = $location.url();
		$scope.updated_transaction = [];
		$scope.new_user = {};
		$scope.user_list = [];
		$scope.user_info = {};
		$scope.welcome_message = "";
		$scope.edit_user = false;
		$scope.updated_user = {};
		$scope.report = "";
		$scope.today = new Date();
		$scope.date_for_sorting = transactionFactory.date_for_sorting;
		$scope.message_log = userFactory.message_log;
		$scope.page_titles = {
			'/': "User Login", 
			'/matrix': "Dues Matrix", 
			'/reports': "Account Balance", 
			'/transactions': "Transaction Browser", 
			'/transactions/new': "Transaction Entry", 
			'/units': "Unit Directory",
			'/taxes': "Property Tax Information",
			'/mortgage': "Blanket Mortgage Status", 
			'/login': "User Login",
			'/feedback': "Submit Feedback",
			'/documents': "Governing Documents & Useful Links",
			'/budget': "Current Budget",
			'/spending_history': "Coop Spending History",
			'/preferences': "User Preferences & Email Reminder Signup",
			'/shareholder_accounts': "Shareholder Accounts"
		};
		$scope.this_page_title = $scope.page_titles[$location.url()];
		$scope.location = $location.url();
		userFactory.index(function(user_index){  //run the full version of this here (i.e. as-is).  preloaded version is better for things that don't run at startup.
			if (user_index.error){
				userFactory.log('error', "Error retrieving user list: " + user_index.error);
			} else {			
				$scope.user_list = user_index.users;
			}
		})
		$scope.login_info = {unit: "Admin", pw: 'wilana_calc'};  //sets default login name.  remove for real use
		$scope.welcome = function(){
			if ($scope.admin === true){
				return "Hi, Admin!";
			} else if ($scope.current_user){
				return "Hi, Unit " + $scope.current_user + "!";
			} else {
				return "You are not logged in.";
			}
		}
		$scope.clear_log = function(){
			userFactory.log("clear");
		}
		$scope.new_nav_topic = function(nav_topic){
			userFactory.nav_topic = nav_topic;
			$scope.nav_topic = userFactory.nav_topic;
		}
		$scope.refresh_log = function(){
			$scope.$evalAsync(userFactory.log());
		}
		$scope.unit_transaction_reference_health = function(){
			reportFactory.reference_health(function(result){
				if (result === "ok"){
					userFactory.log('message', "Unit & Transaction references look perfect.");
				} else {
					//console.log(JSON.stringify(result));
					if (result.runaway_transactions.length > 0){
						userFactory.log('error', "" + result.runaway_transactions.length + ' transactions believe themselves owned by a different unit.  See list in console.');
						for (i=0;i<result.runaway_transactions.length;i++){
							//console.log('Transaction: ' + JSON.stringify(result.runaway_transactions[i].transaction) + " and claimant, unit " + result.runaway_transactions[i].unit_number);
						}
					}
					if (result.rejecting_units.length > 0){
						userFactory.log('error', "" + result.rejecting_units.length + ' units reject clinging transactions.  See list in console.');
						for (i=0;i<result.runaway_transactions.length;i++){
							//console.log('Unit: ' + JSON.stringify(result.rejecting_units[i].unit) + " and clingant, transaction " + JSON.stringify(result.rejecting_units[i].transaction));			
						}
					}
				}
			})
		}
		$scope.register = function(user_info){
			userFactory.register(user_info, function(result){
				if (result.error){
					userFactory.log('error', "Error registering new user: " + result.error);
				} else {
					userFactory.log('message', "Registration completed.");
					$location.url('/login');
				}
			})
		}
		$scope.login = function(login_info){
			userFactory.login(login_info, function(result){
				if (result.error){
					userFactory.log('error', ("Error during login: " + result.error));
				} else {
					$scope.logged_in = userFactory.logged_in;
					$scope.current_user = userFactory.current_user;
					$scope.admin = userFactory.admin;
					userFactory.log('message', "Login completed.");
					$location.url('/units');
				}
			})
		}
		$scope.load_gin = function(){
			var auth2 = gapi.auth2.getAuthInstance();
			auth2.signIn();
			console.log("load_gin completed");
		}
		$scope.onSignIn = function(googleUser) { //not sure anything calls this yet
  			var profile = googleUser.getBasicProfile();
  			console.log('ID: ' + profile.getId()); // Do not send to your backend! Use an ID token instead.
 			console.log('Name: ' + profile.getName());
 			console.log('Image URL: ' + profile.getImageUrl());
			console.log('Email: ' + profile.getEmail());
		}
		$scope.logout_google = function(){
 			var auth2 = gapi.auth2.getAuthInstance();
    		auth2.signOut().then(function () {
      			console.log('User signed out.');
      		});
		}
		$scope.logout = function(){
			userFactory.logout({unit: userFactory.current_user}, function(result){
				if (result.error){
					userFactory.log('error', "Error during logout: " + result.error);
				} else if (result.logged_out){
					$scope.logged_in = false;
					$scope.current_user = "";
					$scope.admin = false;
					userFactory.log('message', "Logout completed.  These should all be false: " + $scope.logged_in + $scope.admin + userFactory.admin);
					$scope.welcome_message = "You have been logged out";
					$location.url("/");
				}
			})
		}
		$scope.logoff_many = function(){
			userFactory.logout_many($scope.user_list, function(result){
				userFactory.log('message', 'Mass logout result: ' + JSON.stringify(result));;
			})
		}
		$scope.update_user = function(){
			console.log("in user factory, about to update password");
			userFactory.update_user($scope.updated_user, function(result){
				if (result.error){
					userFactory.log('error', "Error updating user: " + result.error);
				} else {
					$scope.updated_user = {};
					$scope.edit_user = false;
					userFactory.log('message', 'User update completed.  Server response: ' + result.result);
				}
			})
		}
	}]);
	myApp.controller('expendituresController', ['$scope', 'expenditureFactory', 'userFactory', function($scope, expenditureFactory, userFactory){
		var today = new Date();
		$scope.admin = userFactory.admin;
		$scope.new_line = {};
		$scope.these_years = {}; 
		$scope.current_categories = [];
		$scope.show_these = {maintenance: false, new_line_form: false};
		$scope.checked_all = false;
		$scope.chart_data = {};
		$scope.expense_chart_options = {};
		$scope.income_chart_options = {};
		for (year=2007;year<=today.getFullYear();year++){
			$scope.these_years[year] = {};
		}
		expenditureFactory.index(function(new_index){
			if (new_index.error){
				userFactory.log("error", "Error retrieving spending history index.");
			} else {
				$scope.supercategory_index = new_index.by_supercategory;
				$scope.expense_chart_data = new_index.index_for_chart.expense_categories;
				$scope.income_chart_data = new_index.index_for_chart.income_categories;;
				var chart_series = [];
				var color_variator = 3;
				var default_red = 40;
				var default_green = 180;
				var default_blue = 200;
				var count = 0;
				for (this_category in new_index.index_for_chart.expense_categories){
					count += 1;
					chart_series.push({"dataset": this_category, "color": "rgb(" + String(default_red+count*color_variator) + "," + String(default_green-count*color_variator) + "," + String(default_blue-count*color_variator) + ")", "key": "amount", "label": this_category, "type": "line"});
				}
				$scope.expense_chart_options = {"axes":{"x":{"key":"year"}}, "series": chart_series};
				chart_series = [];
				for (this_category in new_index.index_for_chart.income_categories){
					count += 1;
					chart_series.push({"dataset": this_category, "color": "rgb(" + String(default_red+count*color_variator) + "," + String(default_green+count*color_variator) + "," + String(default_blue-count*color_variator) + ")", "key": "amount", "label": this_category, "type": "line"});
				}
				$scope.income_chart_options =  {"axes":{"x":{"key":"year"}},"series": chart_series};
				console.log("final expense_chart_options: " + JSON.stringify($scope.expense_chart_options));
				console.log("final income_chart_options: " + JSON.stringify($scope.income_chart_options));
			}
		})
		$scope.toggle = function(element){
			$scope.show_these[element] = !$scope.show_these[element];
			console.log($scope.show_these);
		}
		$scope.check_all = function(){		//checks all years that are fully complete as true
			if (!$scope.checked_all){
				for (year=2007;year<today.getFullYear();year++){
					$scope.these_years[year].included = true;
				}
			} else {
				for (year=2007;year<today.getFullYear();year++){
					$scope.these_years[year].amount = "";
					$scope.these_years[year].included = false;
				}
			}
			$scope.checked_all = !$scope.checked_all;
		}
		$scope.create_budget_line = function(this_new_line){
			this_new_line.values = {};
			var valid_entry = true;
			if (!this_new_line.category){
				userFactory.log("error", "Budget category must have a name.");
				valid_entry = false;
			} else {
				for (i=2007;i<=today.getFullYear();i++){
					if ($scope.these_years[i].included){
						if (!Number($scope.these_years[i].amount) && (Number($scope.these_years[i].amount) != 0)){
							userFactory.log('error', 'Year ' + i + ' must be given a numerical value.');
							valid_entry = false;
						} else {
							this_new_line.values[i] = Number($scope.these_years[i].amount);
						}
					}
				}
			}
			if (valid_entry){
				expenditureFactory.create_budget_line(this_new_line, function(result){
					if (result.error){
						userFactory.log("error", "Error creating new budget line: " + err);
					} else {
						$scope.supercategory_index = result.by_supercategory;
					}
				})
			}
		}
	}]);
	myApp.controller('filtersController', ['$scope', '$rootScope', '$filter', 'reportFactory', 'unitFactory', 'filterFactory', 'transactionFactory', function($scope, $rootScope, $filter, reportFactory, unitFactory, filterFactory, transactionFactory, transactionFilter){
		$scope.transaction_types = transactionFactory.allowed_types;
		$scope.transaction_labels = [];
		$scope.buttons = [];
		$scope.allowed_units = {};
		$scope.allowed_types = {};
		$scope.collapsed_filter_options = {unit: true, type: true, date: true, amount: true};
		unitFactory.numbers_index(function(data){
			var previously_activated_units = filterFactory.get('unit');
			$scope.unit_numbers = data.unit_numbers;
			for (i=0;i<$scope.unit_numbers.length;i++){
				var this_filter = false;
				if (previously_activated_units && $scope.unit_numbers[i] in previously_activated_units){
					this_filter = true;
				} else {
				}
				$scope.buttons.push({name: $scope.unit_numbers[i], label: $scope.unit_numbers[i], screen: "unit", filter: this_filter});
			}
		})
		$scope.type_buttons= [];
		$scope.type_translations = {'dues': 'dues', 'credit': 'credits', 'late_fee': 'late fees', 'other_fee': 'other fees', 'assessment': 'assessments'};
		for (i=0;i<$scope.transaction_types.length;i++){
			$scope.type_buttons.push({name: $scope.transaction_types[i], label: $scope.type_translations[$scope.transaction_types[i]], screen: "type", filter: false});
		}	
		$scope.toggle_button = function(clicked_button){ //clicking a filter button triggers a complicated series of events:
			/* 	1) Relevant filter added/removed from master filter list in filterfactory.
				2) filterFactoyry broadcasts that a filter has updated
				3) TransactionsIndexController hears it and ordere an updated transaction list from report factoryh
				4) update_report in reportFactory checks to make sure there are active filters.  If none, returns an empty list to view.
				5) Otherwise it retrieves the full list of filters and orders them to be used by $filter and returns the filtered results to view.
			*/
			if (clicked_button.filter === false){
				//console.log("adding units, value: " + clicked_button.screen + ", " + clicked_button.label);
				filterFactory.add_filter(clicked_button.screen, clicked_button.name);
				//$scope.filtered_transactions = reportFactory.filtered_transactions;
				//$scope.filtered_transactions = $filter('in_group')({'item_list': $scope.transaction_index, 'group': filterFactory.get(clicked_button.screen), 'property': clicked_button.screen}); 
				//console.log("filtered transactions created & is length " + $scope.filtered_transactions.length);
					//$evalAsync($scope.allowed_units[clicked_button.label] = true);
			} else if (clicked_button.filter === true){
				filterFactory.remove_filter(clicked_button.screen, clicked_button.name);
				//$scope.filtered_transactions = reportFactory.filtered_transactions;
				//$scope.filtered_transactions = $filter('in_group')({'item_list': $scope.transaction_index, 'group': filterFactory.get(clicked_button.screen), 'property': clicked_button.screen}); 
				//console.log("filtered transactions created & is length " + $scope.filtered_transactions.length);
			}
			//console.log("about to change clicked_button.filter from " + clicked_button.filter + " to " + !clicked_button.filter);
			clicked_button.filter = !clicked_button.filter;
		}
		$scope.toggle_filter_options = function(toggled_section){
			$scope.collapsed_filter_options[toggled_section] = !$scope.collapsed_filter_options[toggled_section];
		}
	}]);
	myApp.controller('matrixesController', ['$scope', 'matrixFactory', 'userFactory', function($scope, matrixFactory, userFactory){
		$scope.dues_matrix = [];
		$scope.month_labels = matrixFactory.count_months();
		$scope.dues_matrix = {};
		matrixFactory.index(function(data){
			if (data.error){
				userFactory.log('error', "Error retrieving dues rates: " + data.error);
			} else {
				$scope.dues_matrix = data;
				userFactory.log('message', 'Dues rate matrix loaded.');
			}
		})
	}]);
	myApp.controller('filters_v2Controller', [
		'$scope', 
		'$rootScope', 
		'$filter', 
		'reportFactory', 
		'unitFactory', 
		'userFactory',
		'filterFactory', 
		'transactionFactory', 
		function($scope, $rootScope, $filter, reportFactory, unitFactory, userFactory, filterFactory, transactionFactory, transactionFilter){
		$scope.transaction_types = transactionFactory.allowed_types;
		$scope.admin = userFactory.admin;
		$scope.current_user = userFactory.current_user;
		$scope.transaction_labels = [];
		$scope.buttons = [];
		$scope.allowed_units = {};
		$scope.allowed_types = {};
		$scope.info_by_unit ={};
		$scope.collapsed_filter_options = {unit: true, type: true, date: true, amount: true};
		reportFactory.balance_summary(function(result){
			if (result.error){
				userFactory.log('error', "Error retrieving balances summary: " + result.error);
			} else {
				$scope.balance_summary = result; // has format {<unit_number>: <balance>, <unit_number>: <balance>}
				userFactory.log('message', 'Unit balance summary retrieved.');
				console.log("balance summary: " + JSON.stringify($scope.balance_summary));
				if (!$scope.admin && $scope.current_user){
					$scope.shareholder_balance_list = {};
					$scope.balance_total = 0;
					$scope.total_unit_count = Object.keys($scope.balance_summary).length;
					for (i=0;i<$scope.total_unit_count;i++){
						if ($scope.shareholder_balance_list[String($scope.balance_summary[Object.keys($scope.balance_summary)[i]])]){  //complicated way of querying whether each unit's balance value is on the non-admin balance list yet.
							$scope.shareholder_balance_list[String($scope.balance_summary[Object.keys($scope.balance_summary)[i]])] += 1;
						} else {
							$scope.shareholder_balance_list[String($scope.balance_summary[Object.keys($scope.balance_summary)[i]])] = 1;
						}
						$scope.balance_total += Number($scope.balance_summary[Object.keys($scope.balance_summary)[i]]);
					}
				}// I should now have a histogram ready for graphing
			}
		})	
		unitFactory.numbers_index(function(data){
			var previously_activated_units = filterFactory.get('unit');
			$scope.unit_numbers = data.unit_numbers;
			for (i=0;i<$scope.unit_numbers.length;i++){
				var this_filter = false;
				if (previously_activated_units && $scope.unit_numbers[i] in previously_activated_units){
					this_filter = true;
				}
				var this_unit_number = $scope.unit_numbers[i];
				var this_unit_info = {name: this_unit_number, screen: "unit", filter: this_filter, balance: $scope.balance_summary[this_unit_number]};
				console.log(JSON.stringify(this_unit_info));
				$scope.info_by_unit[this_unit_number] = this_unit_info;
			}
		})
		$scope.type_buttons= [];
		$scope.type_translations = {'dues': 'dues', 'credit': 'credits', 'late_fee': 'late fees', 'other_fee': 'other fees', 'assessment': 'assessments'};
		for (i=0;i<$scope.transaction_types.length;i++){
			var this_type = $scope.transaction_types[i];
			var this_label = $scope.type_translations[this_type];
			var this_button_info = {name: this_type, label: this_label, screen: "type", filter: false};
			$scope.type_buttons[i] = {};
			$scope.type_buttons[i][this_label] = this_button_info;
		}
		$scope.toggle_button = function(button_name){ //clicking a filter button triggers a complicated series of events:
			/* 	1) Relevant filter added/removed from master filter list in filterfactory.
				2) filterFactoyry broadcasts that a filter has updated
				3) TransactionsIndexController hears it and ordere an updated transaction list from report factoryh
				4) update_report in reportFactory checks to make sure there are active filters.  If none, returns an empty list to view.
				5) Otherwise it retrieves the full list of filters and orders them to be used by $filter and returns the filtered results to view. */
			if (button_name.screen){ //discerns what sort of button has been clicked (unit buttons have a different structure unforunately).  Using screen because .filter will fail this test if false.
				if (button_name.filter === false){
					filterFactory.add_filter(button_name.screen, button_name.name);
				} else if (button_name.filter === true){
					filterFactory.remove_filter(button_name.screen, button_name.name);
				}
				if (button_name.screen === 'type'){
					$scope.type_buttons[button_name.label] = !$scope.type_buttons[button_name.label];
				} else if (button_name.screen === 'date'){
					$scope.date_buttons[button_name.label] = !$scope.date_buttoons[button_name.label];
				}
			} else {
				if ($scope.info_by_unit[button_name].filter === false){
					filterFactory.add_filter($scope.info_by_unit[button_name].screen, $scope.info_by_unit[button_name].name);
				} else if ($scope.info_by_unit[button_name].filter === true){
					filterFactory.remove_filter($scope.info_by_unit[button_name].screen, $scope.info_by_unit[button_name].name);
				}
				$scope.info_by_unit[button_name].filter = !$scope.info_by_unit[button_name].filter;
			}
		}
		$scope.toggle_filter_options = function(toggled_section){
			$scope.collapsed_filter_options[toggled_section] = !$scope.collapsed_filter_options[toggled_section];
		}
	}]);
	myApp.controller('matrixesController', ['$scope', 'matrixFactory', 'userFactory', function($scope, matrixFactory, userFactory){
		$scope.dues_matrix = [];
		$scope.month_labels = matrixFactory.count_months();
		$scope.dues_matrix = {};
		matrixFactory.index(function(data){
			if (data.error){
				userFactory.log('error', "Error retrieving dues rates: " + data.error);
			} else {
				$scope.dues_matrix = data;
				userFactory.log('message', 'Dues rate matrix loaded.');
			}
		})
	}]);
	myApp.controller('mortgagesController', ['$scope', 'mortgageFactory', 'userFactory', function($scope, mortgageFactory, userFactory){
		$scope.new_mortgage = {};
		$scope.parsed_mortgage = {};
		$scope.mortgage_index = [];
		$scope.main_data = "";
		mortgageFactory.mortgage_index(function(result){
			if (result.error){
				userFactory.log("error", result.error);
			} else {
				userFactory.log("message", "Retrieved mortgage index of length " + result.these_complete_mortgages.length);
				$scope.mortgage_index = result.these_complete_mortgages;		
				$scope.chart_data = {};
				var this_series_data = [];  // 
				var these_payments = []; //not a new entity, just a shortened name for each mortgage's data series
				$scope.chart_options = {axes: {x: {key: "x", type: "date"}}};
				var chart_series = [];  //several of these (one per mortgage) will be added to $scope.chart_options.
				var series_colors = ["rgb(144,24,21)", "rgb(60,36,175)"];
				for (this_index=0;this_index<$scope.mortgage_index.length;this_index++){ // yeah "this_index" is vague, but my usual scheme would be to call it "mortgage_index", which obviously wouldn't work here.
					console.log("starting this_index " + this_index);
					chart_series.push({
						dataset: $scope.mortgage_index[this_index].name, 
						color: series_colors[this_index],
						key: "balance", 
						label: "Remaining Balance", 
						type: "line"
					});
					this_series_data = [{x: new Date($scope.mortgage_index[this_index].initial_date), "balance": $scope.mortgage_index[this_index].initial_balance}];
					these_payments = $scope.mortgage_index[this_index].payments;
					for (month_index=0;month_index<these_payments.length;month_index++){ // iterates through every month constructing data series,
						console.log("starting month_index " + month_index);
						this_series_data.push({x: new Date(these_payments[month_index].pay_date), "balance": $scope.mortgage_index[this_index].running_balances[month_index]});
						if (month_index === (these_payments.length - 1)){
							$scope.chart_data[($scope.mortgage_index[this_index].name)] = this_series_data;  // when finished with the last month, tacks the series onto a permanent site, and starts again
							if (this_index === ($scope.mortgage_index.length -1)){ // if done iterating through all the mortgages
								$scope.chart_options["series"] = chart_series;
								console.log("I think I've iterated through everything.  this_index is " + this_index + " and month_index is " + month_index);
								console.log("chart_data: " + JSON.stringify($scope.chart_data));
								console.log("chart_options: " + JSON.stringify($scope.chart_options));
							}
						}
					}
				}
			};
		});
		$scope.parse_mortgage = function(this_new_mortgage){
			$scope.parsed_mortgage.name = this_new_mortgage.name;
			$scope.parsed_mortgage.initial_date = new Date(this_new_mortgage.initial_date);
			$scope.parsed_mortgage.initial_balance = Number(this_new_mortgage.initial_balance);
			var raw_payment_list = this_new_mortgage.raw_payments.split('\n');
			$scope.parsed_mortgage.payments = [];
			$scope.parsed_mortgage.running_balances = [];
			for (i=0;i<raw_payment_list.length;i++){
				var these_payment_properties = raw_payment_list[i].split('\t');
				if (these_payment_properties.length != 4){
					userFactory.log('error', "Error in mortgage payment format: too few properties at " + these_payment_properties);
				} else if (Number(these_payment_properties[1]) != (Number(these_payment_properties[2]) + Number(these_payment_properties[3])).toFixed(2)){
					userFactory.log('error', "Error in mortgage payment property amounts at: " + these_payment_properties + ".  I don't think " + Number(these_payment_properties[1]) + " equals " + (Number(these_payment_properties[2]) + Number(these_payment_properties[3])).toFixed(2));
				} else {
					$scope.parsed_mortgage.payments.push({
						'pay_date': new Date(these_payment_properties[0]), 
						'total': Number(these_payment_properties[1]), 
						'interest': Number(these_payment_properties[2]), 
						'principal': Number(these_payment_properties[3])
					});
					if ($scope.parsed_mortgage.running_balances.length === 0){			
						$scope.parsed_mortgage.running_balances.push(($scope.parsed_mortgage.initial_balance - $scope.parsed_mortgage.payments[0].principal).toFixed(2));
					} else {
						$scope.parsed_mortgage.running_balances.push(($scope.parsed_mortgage.running_balances[i-1] - $scope.parsed_mortgage.payments[i].principal).toFixed(2));
					}
				}
			}
		}
		$scope.create_mortgage = function(){
			if ($scope.parsed_mortgage === {}){
				$scope.parse_mortgage($scope.new_mortgage)
			}
			mortgageFactory.create_mortgage($scope.parsed_mortgage, function(result){
				if (result.error){
					userFactory.log("error", result.error);
				} else {
					if (result.created_mortgage){
						$scope.mortgage_index.push(result.created_mortgage);
					}
					$scope.new_mortgage = {};
					$scope.parsed_mortgage = {};
					userFactory.log("message", "Mortgage created?  Result: " + JSON.stringify(result));
				}
			})
		}
		$scope.show_mortgage = function(index){
			if (index === "new"){
				$scope.main_data = {'new': true};
				console.log("new is now true");
			} else {
				$scope.main_data = {'show': index};
				console.log("showing other mortgage index " + index);
				$scope.show_this_mortgage = $scope.mortgage_index[index];
				console.log("now showing " + $scope.show_this_mortgage.name);
			}
		}
	}]);	
	myApp.controller('reportsController', ['$scope', 'reportFactory', 'transactionFactory', 'unitFactory', 'userFactory', function($scope, reportFactory, transactionFactory, unitFactory, userFactory){
		$scope.date_for_sorting = transactionFactory.date_for_sorting;
		$scope.active_unit_button = "";
		$scope.admin = userFactory.admin;
		$scope.current_user = userFactory.current_user;
		$scope.generate_report = function(this_unit_number){
			if (!this_unit_number){
				userFactory.log('error', "Please select a unit number.");
			} else {
				$scope.reported_unit = this_unit_number;
				reportFactory.full_history(this_unit_number, function(result){
					$scope.this_report = result.full_history;
					$scope.initial_balance = result.initial_balance;
					userFactory.log('message', 'Report on unit ' + this_unit_number + " generated.");
				})
			}
		}
		if (!$scope.admin && $scope.current_user){
			$scope.generate_report($scope.current_user);
		}
		unitFactory.numbers_index(function(unit_numbers_index){
			if (unit_numbers_index.error){
				userFactory.log('error', "Error retrieving unit numbers: " + unit_numbers_index.error);
			} else {
				$scope.unit_numbers = unit_numbers_index.unit_numbers;
			}
		})
		unitFactory.index({"deposits": true}, function(result){
			if (result.error){
				userFactory.log('error', "Error retrieving deposits: " + result.error);
			} else {
				$scope.deposit_index = result.deposit_index;
			}
		})
		reportFactory.balance_summary(function(result){
			if (result.error){
				userFactory.log('error', "Error retrieving balances summary: " + result.error);
			} else {
				$scope.these_balances = result;
				userFactory.log('message', 'Unit balance summary retrieved.');
				if (!$scope.admin && $scope.current_user){
					$scope.shareholder_balance_list = {};
					$scope.balance_total = 0;
					$scope.total_unit_count = Object.keys($scope.these_balances).length;
					for (i=0;i<$scope.total_unit_count;i++){
						if ($scope.shareholder_balance_list[String($scope.these_balances[Object.keys($scope.these_balances)[i]])]){  //complicated way of querying whether each unit's balance value is on the non-admin balance list yet.
							$scope.shareholder_balance_list[String($scope.these_balances[Object.keys($scope.these_balances)[i]])] += 1;
						} else {
							$scope.shareholder_balance_list[String($scope.these_balances[Object.keys($scope.these_balances)[i]])] = 1;
						}
						$scope.balance_total += Number($scope.these_balances[Object.keys($scope.these_balances)[i]]);
					}
				}
			}
		})
		$scope.unit_button_click = function(unit_number){
			$scope.active_unit_button = unit_number;
			$scope.generate_report(unit_number);
		}
	}]);
	myApp.controller('shareholder_accountsController', ['$scope', 'reportFactory', 'transactionFactory', 'unitFactory', 'userFactory', function($scope, reportFactory, transactionFactory, unitFactory, userFactory){
		console.log('moo');
	}]);
	myApp.controller('taxesController', ['$scope', 'propertyTaxFactory', 'mortgageFactory', 'userFactory', function($scope, propertyTaxFactory, mortgageFactory, userFactory){
		$scope.current_user = userFactory.current_user;
		$scope.admin = userFactory.admin;
		$scope.new_tax = {};
		$scope.new_tax_options = {};
		propertyTaxFactory.index(function(prop_tax){
			if (prop_tax.error){
				userFactory.log('error', "Error retrieving property taxes: " + prop_tax.error);
			} else {
				$scope.property_taxes_by_attribute = prop_tax.index_by_attribute;
			}
		})
		$scope.create_tax = function(this_tax_info){
			if ($scope.new_tax_options.lost_shareholder){
				this_tax_info.units_main = {'small': [6, 7, 8, 9, 15, 16, 17, 18, 24, 25, 26, 27], 'medium': [2, 10, 11, 19, 20, 28, 29], 'large': [4, 5, 12, 14, 21, 22]};
			}
			propertyTaxFactory.create_tax(this_tax_info, function(creation_result){
				if (creation_result.error){
					userFactory.log('error', "Error creating tax year: " + creation_result.error);
				} else {
					$scope.property_taxes_by_attribute = creation_result.index_by_attribute;
				}
			})
		}
		$scope.delete_tax = function(this_tax_id){
			propertyTaxFactory.delete_tax(this_tax_id, function(deletion_result){
				if (deletion_result.error){
					userFactory.log('error', "Error deleting tax year: " + deletion_result.error);
				} else {
					$scope.property_taxes_by_attribute = deletion_result.index_by_attribute;
				}
			})
		}
	}]);
	myApp.controller('transactionsIndexController', ['$scope', '$filter', 'reportFactory', 'transactionFactory', 'userFactory', function($scope, $filter, reportFactory, transactionFactory, userFactory){
		$scope.edit_lock = {type: false, id: null};
		$scope.updated_transaction = {};	
		reportFactory.update_report("transaction_change", function(factory_response){
			$scope.factory_response = factory_response; // depending on context, this will be an object with any of these:  message: string, filtered_transactions: array, sums: {sum: Number, running_balances: list}
			//console.log("controller has received final filterd transaction list: Here is the first: " + JSON.stringify($scope.filtered_transactions[0]));
		});
		$scope.allowed_types = transactionFactory.allowed_types;
		$scope.date_for_sorting = transactionFactory.date_for_sorting;
		//console.log('buttonscontroller f-t length is ' + $scope.filtered_transactions.length);
		$scope.$on('filter_updated', function(){
			//console.log("TransactionsIndex/ButtonsController heard about a filter update and is ordering an updated transaction list");
			reportFactory.update_report("filter_change", function(factory_response){
				$scope.factory_response = factory_response; // depending on context, this will be an object with any of these:  message: string, filtered_transactions: array, sums: {sum: Number, running_balances: list}
				//console.log("buttonsController has received an updated filtered transaction list, length: " + $scope.filtered_transactions.length);
			});
		})
		$scope.sort_criterion = "-date";
		var reverse_sort_strings = {
			"date": "-date", 
			"-date" : "date", 
			"_unit.number": "-_unit.number", 
			"-_unit.number": "_unit.number", 
			"amount": "-amount", 
			"-amount": "amount", 
			"check_number": "-check_number", 
			"-check_number": "check_number", 
			"type": "-type", 
			"-type": "type", 
			"notes": "-notes", 
			"-notes": "notes"
		};
		$scope.sort_by = function(new_criterion){
			if (new_criterion.search($scope.sort_criterion) != -1){ //if user is just reversing the sort order
				$scope.sort_criterion = reverse_sort_strings[$scope.sort_criterion];
			} else {  // if user is sorting by a new column
				$scope.sort_criterion = new_criterion;
			} 
		}
		$scope.cancel = function(){
			$scope.edit_lock = {type: false, id: null};
			$scope.updated_transaction = {};
			userFactory.log('message', 'Action canceled.');
		}
		$scope.edit_transaction = function(this_transaction){
			$scope.updated_transaction = {
				_id: this_transaction._id, 
				_unit: this_transaction._unit, 
				date: this_transaction.date, 
				type: this_transaction.type, 
				amount: (this_transaction.amount / 100).toFixed(2), 
				check_number: this_transaction.check_number, 
				notes: this_transaction.notes
			};
			//console.log("Prepped for editing: " + JSON.stringify($scope.updated_transaction));
			$scope.edit_lock = {type: "edit", id: this_transaction._id};
			userFactory.log('message', 'Transaction prepped for editing.');
		}
		$scope.update_transaction = function(updated_transaction, transaction_id){
			transactionFactory.update(updated_transaction, function(result){
				if (result.error){
					userFactory.log('error', "Update error: " + result.error);
				} else {
					userFactory.log("message", "Update completed.  About to refresh transactions.");
					reportFactory.update_report("transaction_change", function(factory_response){
						$scope.factory_response = factory_response; // depending on context, this will be an object with any of these:  message: string, filtered_transactions: array, sums: {sum: Number, running_balances: list}
						//console.log("controller has received final filterd transaction list: Here is the first: " + JSON.stringify($scope.filtered_transactions[0]));
					});
				}
			})
			$scope.edit_lock = {type: false, id: null};
			$scope.updated_transaction = {};
		}
		$scope.prepare_delete = function(id){
			$scope.edit_lock = {type: "delete", id: id};
		}
		$scope.delete_transaction = function(this_transaction, this_unit){
			transactionFactory.delete_one(this_transaction._id, function(result){
				if (result.error){
					userFactory.log('error', "Error deleting transaction: " + result.error);
				} else {
					reportFactory.update_report("transaction_change", function(factory_response){
						$scope.factory_response = factory_response; // depending on context, this will be an object with any of these:  message: string, filtered_transactions: array, sums: {sum: Number, running_balances: list}
						//console.log("controller has received final filterd transaction list: Here is the first: " + JSON.stringify($scope.filtered_transactions[0]));
					});
					$scope.edit_lock = {type: false, id: null};
					userFactory.log('message', "Transaction deleted.  Server response: " + JSON.stringify(result.result));
				}
			})
		}
		/*$scope.delete_transaction = function(this_transaction, this_unit){
			transactionFactory.delete_one(this_transaction._id, function(result){
				if (result.error){
					userFactory.log('error', "Error deleting transaction: " + result.error);
				} else {
					var this_index = $scope.index_by_unit[this_unit].indexOf(this_transaction);
					$scope.index_by_unit[this_unit].splice(this_index, 1);
					$scope.edit_lock = {type: false, id: null};
					userFactory.log('message', "Transaction deleted.  Server response: " + JSON.stringify(result.result));
				}
			})
		}*/
	}]);
	myApp.controller('transactionsNewController', ['$scope', 'transactionFactory', 'unitFactory', 'userFactory', function($scope, transactionFactory, unitFactory, userFactory){
		$scope.display_prep = {};
		$scope.allowed_types = transactionFactory.allowed_types;
		$scope.delete_confirmation_pending = false;
		$scope.clear_check_number = function(){
			if ($scope.new_transaction.type != "credit"){
				$scope.new_transaction.check_number = "";
				//console.log('new check no = ' + $scope.new_transaction.check_number);
			}
		}
		unitFactory.numbers_index(function(data){
			if (data.error){
				userFactory.log('error', "Error retrieving unit numbers: " + data.error);
			} else {
				$scope.unit_list = data.unit_numbers;
			}
		})
		$scope.add_tab = function(){
			$scope.update_input = $scope.update_input + "\t";
			$scope.$broadcast("tab_added");
			console.log("should have broadcast tab_addded");
		}
		$scope.delete_all = function(){
			$scope.delete_confirmation_pending = false;
			transactionFactory.delete_all(function(result){
				if (result.error){
					userFactory.log('error', "Error while mass deleting: " + JSON.stringify(result.error));
				} else {
					userFactory.log('message', "All transactions deleted.  Server response: " + JSON.stringify(result));
				}
			})
		}
		$scope.prepare_update = function(){
			var raw_update = {};
			raw_update.lines = $scope.update_input.split('\n');
			for (i=0; i<raw_update.lines.length; i++){
				raw_update.lines[i] = raw_update.lines[i].split('\t');
			}
			if (raw_update.lines.length < 2){
				userFactory.log('error', "Update must contain at least 2 lines.");
			} else {
				$scope.display_prep = raw_update.lines;
				userFactory.log('message', "New transactions prepared for upload.");
			}
		}
		$scope.create_transactions = function(){
			transactionFactory.create_transactions($scope.display_prep, function(data){
				if (data.error){
					userFactory.log("error", "Error uploading transactions: " + data.error);
				} else {
					userFactory.log("New transactions uploaded.  Server response: " + JSON.stringify(data.result));
				}
			})
		}
		$scope.create_transaction = function(new_payment){
			transactionFactory.create_transaction(new_payment, function(data){
				if (data.error){
					userFactory.log('error', 'Error creating transaction: ' + data.error);
				} else {
					/*var used_date = $scope.new_transaction.date;
					console.log("used date: " + used_date);
					used_date = new Date(used_date);
					console.log("Dated used date: " + used_date);
					if (used_date.getMonth() < 12){
						console.log("About to add month");
						used_date.setMonth(used_date.getMonth() + 1); 
						console.log("Added month: " + used_date);
					}
					console.log("before apply: new transaction " + $scope.new_transaction.date + " & used_date " + used_date.toLocaleDateString());
					$scope.$apply($scope.new_transaction.date = used_date.toLocaleDateString());
					console.log("after apply: " + $scope.new_transaction.date);	*/
					$scope.saved_transaction = data.saved_transaction;
					userFactory.log("message", 'Transaction created.');
				}
			})
		}
	}]);
	myApp.controller('unitsController', ['$scope', 'unitFactory', 'userFactory', function($scope, unitFactory, userFactory){
		unitFactory.index({populate: true}, function(these_units){
			if (these_units.error){
				userFactory.log('error', "Error retrieving unit index: " + these_units.error);
			} else {
				$scope.unit_index = these_units.index;
			}
		})
		$scope.create = function(new_unit){
			unitFactory.create(new_unit, function(new_index){
				if (new_index.error){
					userFactory.log('error', "Error creating unit: " + new_index.error);
				} else {
					$scope.unit_index = new_index.index;
					userFactory.log('message', "Unit created");
				}
			})
		}
		$scope.update = function(this_unit){
			unitFactory.update(this_unit, function(new_index){
				if (new_index.error){
					userFactory.log('error', "Error updating unit: " + new_index.error);

				} else {
					$scope.unit_index = new_index.index;
					userFactory.log('message', "Unit updated.");
				}
			})
		}
	}]);
	</script>
	<script type="text/javascript" src="https://apis.google.com/js/platform.js?onload=init" async defer></script>
	<meta name="google-signin-client_id" content="544028406258-p756lflvl7dqrap03ajh3kogfmc873pf.apps.googleusercontent.com">
</head>
<body ng-app='myApp'>
 	<div ng-view></div>
</body>