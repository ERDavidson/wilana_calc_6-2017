<!DOCTYPE HTML>
<html>
<head>
	<title>Wilana Calc</title>
	<meta charset="utf-8">
	<link rel='stylesheet' type='text/css' href='./static/style.css'>
	<link rel='stylesheet' type='text/css' href='./static/nv.d3.css'>
	<!---<link rel='stylesheet' type='text/css' href='./static/LineChart.css'>-->
	<script type="text/javascript" src="./client_modules/angular.js"></script>
	<script type="text/javascript" src="./client_modules/angular-route-1_5_5.js"></script>
	<script type="text/javascript" src="./client_modules/isaac.js"></script>
	<script type="text/javascript" src="./client_modules/bcrypt.js"></script>
	<script type="text/javascript" src="./client_modules/angular-animate.js"></script>
	<script type="text/javascript" src="./client_modules/d3.js"></script>
	<script type="text/javascript" src="./client_modules/nv.d3.js"></script>
	<script type="text/javascript" src="./client_modules/angular-nvd3.js"></script>
	<script type="text/javascript" src="./wc3_services.js"></script>
	<!--<script type="text/javascript" src="./LineChart.js"></script>-->
	<script>
	var myApp = angular.module("myApp", ['ngRoute', 'ngAnimate', 'nvd3', 'wc3_services']);
	var wc3_services = angular.module("wc3_services");
	var ngAnimate = angular.module("ngAnimate");

	myApp.config(function($routeProvider){
		$routeProvider
			.when('/', {
				templateUrl: './partials/welcome.html'
			})
			.when('/login', {
				templateUrl: './partials/welcome.html'
			})
			.when('/matrix', {
				templateUrl: './partials/matrix_show.html'
			})
			.when('/reports', {
				templateUrl: './partials/reports.html',
				controller: 'reportsController'
			})
			.when('/transactions/new', {
				templateUrl: './partials/transactions_new.html'
			})
			.when('/transactions', {
				templateUrl: './partials/transactions_index.html',
				controller: 'transactionsIndexController'
			})
			.when('/units', {
				templateUrl: './partials/units_index_new_edit.html'
			})
			.when('/taxes', {
				templateUrl: './partials/taxes.html',
				controller: 'taxesController'
			})
			.when('/mortgage', {
				templateUrl: './partials/mortgage.html',
				controller: 'mortgagesController'
			})
			.when('/feedback', {
				templateUrl: './partials/feedback.html',
				controller: 'feedbacksController'
			})
			.when('/documents', {
				templateUrl: './partials/documents.html',
				controller: 'documentsController'
			})
			.when('/budget', {
				templateUrl: './partials/budget.html'
			})
			.when('/spending_history', {
				templateUrl: './partials/spending_history.html',
				controller: 'expendituresController'
			})
			.when('/preferences', {
				templateUrl: './partials/preferences.html',
				controller: 'preferencesController'
			})
			.otherwise({
				redirectTo: '/partials/welcome.html'
			});
	});
	
	myApp.controller('appController', ['$scope', '$rootScope', '$location', 'userFactory', 'reportFactory', 'transactionFactory', 'feedbackFactory', function($scope, $rootScope, $location, userFactory, reportFactory, transactionFactory, feedbackFactory){	
		//console.log("loading appController");
		$scope.current_user = userFactory.current_user;
		$scope.logged_in = userFactory.logged_in;
		$scope.admin = userFactory.admin;

		if (!$scope.logged_in){
			$location.url("/login");
		}
		$scope.logout_result = "";
		$scope.nav_topic = userFactory.nav_topic;
		$scope.this_view = $location.url();
		$scope.updated_transaction = [];
		$scope.new_user = {};
		$scope.user_list = [];
		$scope.user_info = {};
		$scope.welcome_message = "";
		$scope.edit_user = false;
		$scope.updated_user = {};
		$scope.report = "";
		$scope.today = new Date();
		$scope.date_for_sorting = transactionFactory.date_for_sorting;
		$scope.message_log = userFactory.message_log;
		$scope.page_titles = {
			'/': "User Login", 
			'/matrix': "Dues Matrix", 
			'/reports': "Account Balance", 
			'/transactions': "Transaction Browser", 
			'/transactions/new': "Transaction Entry", 
			'/units': "Unit Directory",
			'/taxes': "Property Tax Information",
			'/mortgage': "Blanket Mortgage Status", 
			'/login': "User Login",
			'/feedback': "Submit Feedback",
			'/documents': "Governing Documents & Useful Links",
			'/budget': "Current Budget",
			'/spending_history': "Coop Spending History",
			'/preferences': "User Preferences & Email Reminder Signup",
		};
		$scope.this_page_title = $scope.page_titles[$location.url()];
		$scope.location = $location.url();
		userFactory.index(function(user_index){  //run the full version of this here (i.e. as-is).  preloaded version is better for things that don't run at startup.
			if (user_index.error){
				userFactory.log('error', "Error retrieving user list: " + user_index.error);
			} else {			
				$scope.user_list = user_index.users;
			}
		})
		$scope.login_info = {unit: "Admin", pw: 'wilana_calc'};  //sets default login name.  remove for real use
		$scope.welcome = function(){
			if ($scope.admin === true){
				return "Hi, Admin!";
			} else if ($scope.current_user){
				return "Hi, Unit " + $scope.current_user + "!";
			} else {
				return "You are not logged in.";
			}
		}
		$scope.clear_log = function(){
			userFactory.log("clear");
		}
		$scope.new_nav_topic = function(nav_topic){
			userFactory.nav_topic = nav_topic;
			$scope.nav_topic = userFactory.nav_topic;
			//console.log("new nav topic: " + nav_topic);
		}
		$scope.refresh_log = function(){
			$scope.$evalAsync(userFactory.log());
		}
		$scope.register = function(user_info){
			userFactory.register(user_info, function(result){
				if (result.error){
					userFactory.log('error', "Error registering new user: " + result.error);
				} else {
					userFactory.log('message', "Registration completed.");
					$location.url('/reports');

				}
			})
		}
		$scope.login = function(login_info){
			userFactory.login(login_info, function(result){
				if (result.error){
					userFactory.log('error', ("Error during login: " + result.error));
				} else {
					$scope.logged_in = userFactory.logged_in;
					$scope.current_user = userFactory.current_user;
					$scope.admin = userFactory.admin;
					if ($scope.admin){
						//console.log("checking mail");
						feedbackFactory.check_mail();
					}
					userFactory.log('message', "Login completed.");
					$location.url('/reports');
				}
			})
		}
		$scope.googlelogintest = function(){
			console.log("in user controller googlelogintest method");
			userFactory.googlelogintest(function(result){
				//console.log(result);
			})
		}
		$scope.load_gin = function(){
			console.log("in user controller load_gin method");
			var auth2 = gapi.auth2.getAuthInstance();
			auth2.signIn();
			console.log("load_gin completed");
		}
		$scope.onSignIn = function(googleUser) { //not sure anything calls this yet
			console.log("in user controller onSignIn method");
  			var profile = googleUser.getBasicProfile();
  			//console.log('ID: ' + profile.getId()); // Do not send to your backend! Use an ID token instead.
 			//console.log('Name: ' + profile.getName());
 			//console.log('Image URL: ' + profile.getImageUrl());
			//console.log('Email: ' + profile.getEmail());
		}
		$scope.logout_google = function(){
			console.log("in user controller logout_google method");
 			var auth2 = gapi.auth2.getAuthInstance();
    		auth2.signOut().then(function () {
      			console.log('User signed out.');
      		});
		}
		$scope.logout = function(){
			userFactory.logout({unit: userFactory.current_user}, function(result){
				if (result.error){
					userFactory.log('error', "Error during logout: " + result.error);
				} else if (result.logged_out){
					$scope.logged_in = false;
					$scope.current_user = "";
					$scope.admin = false;
					userFactory.log('message', "Logout completed.  These should all be false: " + $scope.logged_in + $scope.admin + userFactory.admin);
					$scope.welcome_message = "You have been logged out";
					$location.url("/");
				}
			})
		}
		$scope.logoff_many = function(){
			userFactory.logout_many($scope.user_list, function(result){
				userFactory.log('message', 'Mass logout result: ' + JSON.stringify(result));;
			})
		}
		$scope.update_user = function(){
			//console.log("in user controller, about to update password: " + JSON.stringify($scope.updated_user));;
			userFactory.update_user($scope.updated_user, function(result){
				if (result.error){
					userFactory.log('error', "Error updating user: " + result.error);
				} else {
					$scope.updated_user = {};
					$scope.edit_user = false;
					userFactory.log('message', 'User update completed.  Server response: ' + result.result);
				}
			})
		}
	}]);
	myApp.controller('documentsController', ['$scope', "userFactory", function($scope, userFactory){
		$scope.current_user = userFactory.current_user;
		$scope.admin = userFactory.admin;
		$scope.library_info = {"prof_services": {label: "Professionals familiar with the Wilana", tooltip_info: "Plumbers, washing machine service hotline, etc.", show: true},  "links": {label: "Helpful IRS links", tooltip_info: "updated for tax year 2016", show: true}, "governing_docs": {label: "Wilana Governing Documents", tooltip_info: "not yet implemented", show: false}, "minutes": {label: "Meeting  Minutes", tooltip_info: "not yet implemented", show: false}};
		$scope.toggle_library = function(library_section_key){
			//console.log("library button clicked: " + library_section_key);
			$scope.library_info[library_section_key].show = !($scope.library_info[library_section_key].show);
		}
	}]);
	myApp.controller('expendituresController', ['$scope', 'expenditureFactory', 'balanceHistoryFactory', 'mortgageFactory', 'userFactory', function($scope, expenditureFactory, balanceHistoryFactory, mortgageFactory, userFactory){
		var today = new Date();
		var heard_from = {"mortgageFactory": false, "expenditureFactory": false};
		var partial_expense_data = [];
		$scope.admin = userFactory.admin;
		$scope.new_line = {};
		$scope.these_years = {}; 
		$scope.current_categories = [];
		$scope.show_these = {maintenance: false, new_line_form: false};
		$scope.checked_all = false;
		$scope.chart_data = {};
		$scope.recorded_incomes = {};
		$scope.expense_chart_options = {};
		$scope.income_chart_options = {};
		$scope.expense_chart_data = [];
		$scope.income_chart_data = [];
		$scope.new_balance_history = {};
		$scope.balance_histories_data = [];
		for (year=2007;year<=today.getFullYear();year++){
			$scope.these_years[year] = {};
		}
		expenditureFactory.index(function(new_index){
			if (new_index.error){
				userFactory.log("error", "Error retrieving spending history index.");
			} else {
				partial_expense_data = partial_expense_data.concat(new_index.expense_chart_data);
				if (heard_from["mortgageFactory"] === true){				//this is a convoluted attempt to get the chart to render correctly, since I'm having difficulty getting sequentially added data compiled correctly.   if mortgagefactory has reported, we need to collect its data before overwriting scope objects
					//$scope.supercategory_index.Mortgage.Total["2017"] = new_index.by_supercategory.Mortgage.Total["2017"];
					//new_index.by_supercategory.Mortgage.Total = $scope.supercategory_index.Mortgage.Total;
					//new_index.expense_chart_data[0].values = new_index.expense_chart_data[0].values.concat(partial_expense_data[2].values) //add budgeted mortgage total to pre-arrived mortgage history
					//the above is an attempt to bring budgeted mortgage total into expense chart format. But chart does not yet support mortgage totals, and that seems low priority - FAR easier to just budget for interest & principal
					//console.log("heard from mortgage factory first");
					$scope.expense_chart_data = partial_expense_data;
				}
				$scope.supercategory_index = new_index.by_supercategory;
				heard_from["expenditureFactory"] = true;
				$scope.income_chart_data = $scope.income_chart_data.concat(new_index.income_chart_data);
				console.log("Lots of indexes:  Supercat, expense_chart, income_chart: ");
				console.log(new_index);
				$scope.chart_options = {
					'chart': {
						"type": 'stackedAreaChart',
						"height": 450, 
						"margin": {
							top: 20,
							right: 60,
							bottom: 30,
							left: 120
						},
						"x": function(d){return d[0];},
						"y": function(d){return d[1];},
						"useVoronoi": false,
						"clipEdge": true,
						"duration": 400,
						useInteractiveGuideline: true,
						xAxis: {
							showMaxMin: false,
							tickFormat: function(d){
								if (d === 2017){
									d = "Budget " + String(d);
								}
								return (d);
								//return d3.time.format('%x')(new Date(d))
							}
						},
						yAxis: {
							tickFormat: function(d){
								return ("$" + d3.format(',.2f')(d));
							}
						},
						zoom: {
							enabled: false,
							scaleExtent: [1,10],
							useFixedDomain: false,
							useNiceScale: false,
							horiontalOff: false,
							verticalOff: true,
							unzoomEventType: 'dblclick.zoom'
						}
					}
				};
				//$scope.income_chart_options =  {"axes":{"x":{"key":"year"}},"series": chart_series};
				//console.log("final chart_options: " + JSON.stringify($scope.expense_chart_options));
			}
		})
		expenditureFactory.get_recorded_incomes(function(result){
			$scope.recorded_incomes = result.incomes;
		})
		mortgageFactory.index_by_year(function(result){
			//$scope.expense_chart_data.push(result.for_chart[0]);
			//$scope.expense_chart_data.push(result.for_chart[1]); //   this leaves off total for now
			partial_expense_data = partial_expense_data.concat(result.for_chart.slice(0,2)); 
			heard_from["mortgageFactory"] = true;
			if (heard_from["expenditureFactory"] === true){
				console.log("Heard from expense factory first");
				$scope.expense_chart_data = partial_expense_data;
			}
			$scope.supercategory_index.Mortgage = result.for_table.Mortgage;  //then you can overwrite the carrier of the budgeted value.
			console.log("Done adding mortgage to expense data:");
			console.log(partial_expense_data);

		})
		balanceHistoryFactory.index(function(these_histories){
			if (these_histories.error){
				userFactory.log("error", "Error retrieving balance history index");
			} else {
				$scope.balance_histories_data = these_histories.histories_for_chart;
				$scope.balance_histories_options = {
					"chart": {
						"type": "multiChart",
						"height": 450,
						"margin": {
							"top": 20,
							"right": 20,
							"bottom": 30,
							"left": 40
						},
						"useVoronoi": false,
						"clipEdge": true,
						"duration": 100,
						"useInteractiveGuideline": true,
						"xAxis": {
							"showMaxMin": false
						},
						"yAxis": {},
						"zoom": {
							"enabled": true,
							"scaleExtent": [
								1,
								10
							],
							"useFixedDomain": false,
							"useNiceScale": false,
							"horizontalOff": false,
							"verticalOff": true,
							"unzoomEventType": "dblclick.zoom"
						}
					}
				/*{
					'chart': {
						"type": 'stackedAreaChart',
						"height": 200, 
						"margin": {
							top: 20,
							right: 60,
							bottom: 30,
							left: 120
						},
						"x": function(d){return d[0];},
						"y": function(d){return d[1];},
						"useVoronoi": false,
						"clipEdge": true,
						"duration": 400,
						useInteractiveGuideline: true,
						xAxis: {
							showMaxMin: false,
							tickFormat: function(d){
								return d3.time.format('%x')(new Date(d))
							}
						},
						yAxis: {
							tickFormat: function(d){
								return ("$" + d3.format(',.2f')(d));
							}
						},
						zoom: {
							enabled: false,
							scaleExtent: [1,10],
							useFixedDomain: false,
							useNiceScale: false,
							horiontalOff: false,
							verticalOff: true,
							unzoomEventType: 'dblclick.zoom'
						}
					}*/
				};
				console.log("balance histories options:");
				console.log($scope.balance_histories_options);
				console.log("balance histories data:");
				console.log($scope.balance_histories_data);
			}
		})
		$scope.toggle = function(element){
			$scope.show_these[element] = !$scope.show_these[element];
			//console.log($scope.show_these);
		}
		$scope.check_all = function(){		//checks all years that are fully complete as true
			if (!$scope.checked_all){
				for (year=2007;year<today.getFullYear();year++){
					$scope.these_years[year].included = true;
				}
			} else {
				for (year=2007;year<today.getFullYear();year++){
					$scope.these_years[year].amount = "";
					$scope.these_years[year].included = false;
				}
			}
			$scope.checked_all = !$scope.checked_all;
		}
		$scope.create_budget_line = function(this_new_line){
			this_new_line.values = {};
			var valid_entry = true;
			if (!this_new_line.category){
				userFactory.log("error", "Budget category must have a name.");
				valid_entry = false;
			} else {
				for (i=2007;i<=today.getFullYear();i++){
					if ($scope.these_years[i].included){
						if (!Number($scope.these_years[i].amount) && (Number($scope.these_years[i].amount) != 0)){
							userFactory.log('error', 'Year ' + i + ' must be given a numerical value.');
							valid_entry = false;
						} else {
							this_new_line.values[i] = Number($scope.these_years[i].amount);
						}
					}
				}
			}
			if (valid_entry){
				expenditureFactory.create_budget_line(this_new_line, function(result){
					if (result.error){
						userFactory.log("error", "Error creating new budget line: " + err);
					} else {
						$scope.supercategory_index = result.by_supercategory;
					}
				})
			}
		}
		$scope.create_balance_history = function(this_new_history){
			this_new_history.dates = this_new_history.dates.split('\n');
			this_new_history.values = this_new_history.values.split('\n');
			if ((this_new_history.dates.length === this_new_history.values.length) && (this_new_history.dates.length > 0)){
				balanceHistoryFactory.create(this_new_history, function(result){
					if (result.error){
						userFactory.log("error", "Error creating balance history: " + result.error);
					} else {
						userFactory.log("message", "Balance history created with no errors detected.");
						$scope.new_balance_history = {};
					}
				})
			} 
		}
	}]);
	myApp.controller('feedbacksController', ['$scope', 'feedbackFactory', 'userFactory', 'unitFactory', function($scope, feedbackFactory, userFactory, unitFactory){
		$scope.current_user = userFactory.current_user;
		$scope.admin = userFactory.admin;
		$scope.today = new Date();
		$scope.submitted_feedback = false;
		if ($scope.admin){
			feedbackFactory.index(function(result){
				if (result.error){
					userFactory.log("error", "Error retrieving feedback index: " + result.err);
				} else {
					$scope.feedback_index = result.feedback_index;
				}
			})
		}
		$scope.create_feedback = function(new_message){
			new_message.date = new Date();
			new_message.unit = $scope.current_user;
			feedbackFactory.create_feedback(new_message, function(result){
				if (result.error){
					userFactory.log("error", "Error submitting feedback: " + result.error);
				} else {
					$scope.feedback_submitted = true;
					$scope.created_feedback = result.submitted_feedback;
				}
			})
		}
		$scope.delete = function(old_id){
			feedbackFactory.delete_feedback(old_id, function(result){
				if (result.error){
					userFactory.log("error", "Error deleting feedback: " + result.error);
				} else {
					userFactory.log("message", "Feedback deleted: " + JSON.stringify(result));
					feedbackFactory.index(function(result){
						if (result.error){
							userFactory.log("error", "Error retrieving feedback index: " + result.err);
						} else {
							$scope.feedback_index = result.feedback_index;
						}
					})
				}
			})
		}	
	}]);
	myApp.controller('matrixesController', ['$scope', 'matrixFactory', 'userFactory', function($scope, matrixFactory, userFactory){
		$scope.dues_matrix = [];
		$scope.month_labels = matrixFactory.count_months();
		$scope.dues_matrix = {};
		matrixFactory.index(function(data){
			if (data.error){
				userFactory.log('error', "Error retrieving dues rates: " + data.error);
			} else {
				$scope.dues_matrix = data;
				userFactory.log('message', 'Dues rate matrix loaded.');
			}
		})
	}]);
	myApp.controller('mortgagesController', ['$scope', 'mortgageFactory', 'userFactory', function($scope, mortgageFactory, userFactory){
		$scope.new_mortgage = {};
		$scope.parsed_mortgage = {};
		$scope.mortgage_index = [];
		$scope.main_data = "";
		mortgageFactory.mortgage_index(function(result){
			if (result.error){
				userFactory.log("error", result.error);
			} else {
				//userFactory.log("message", "Retrieved mortgage index of length " + result.these_complete_mortgages.length);
				$scope.mortgage_index = result.these_complete_mortgages;	
				//console.log("mortage_index:");
				//console.log($scope.mortgage_index);	
				$scope.mortgage_chart_data = [];
				var key_mortgage = {};
				var fortune_mortgage = {};
				//var this_series_data = [];  // 
				var these_payments = []; //not a new entity, just a shortened name for each mortgage's data series
				//$scope.chart_options = {axes: {x: {key: "x", type: "date"}}};
				//var chart_series = {};  //several of these (one per mortgage) will be added to $scope.chart_options.
				var series_colors = {"Key Bank Mortgage": "rgb(144,24,21)", "Fortune Bank Loan": "rgb(60,36,175)"};
				$scope.mortgage_chart_options = {
					"chart": {
						"type": "lineChart",
						"height": 720,
						"width": 1150,
						"margin": {
							"top": 20,
							"right": 40,
							"bottom": 30,
							"left": 120
						},
						"x": function(d){ return d[0];},
						"y": function(d){ return d[1];},
						"duration": 100,
						"useInteractiveGuideline": true,
						"xAxis": {
							"showMaxMin": true,
							tickFormat: function(d){
								return d3.time.format('%x')(new Date(d));
							}
						},
						"yAxis": {
							tickFormat: function(d){
								return ("$" + d3.format(',.2f')(d/100));
							}
						},
						"zoom": {
							"enabled": false
						}
					}

				};
				if ($scope.mortgage_index[0].name === "Key Bank Mortgage"){
					key_mortgage = $scope.mortgage_index[0];
					fortune_mortgage = $scope.mortgage_index[1];
				} else if ($scope.mortgage_index[0].name === "Fortune Bank Loan"){
					key_mortgage = $scope.mortgage_index[1];
					fortune_mortgage = $scope.mortgage_index[0];
				} else {
					//console.log("Something is very wrong with mortgage parsing.");
				}
				$scope.mortgage_chart_prep = [{
					"key": key_mortgage.name, 
					"color": series_colors[key_mortgage.name], 
					"values": []
				}, {
					"key": fortune_mortgage.name, 
					"color": series_colors[fortune_mortgage.name], 
					"values": []
				}];
				for (month_index=0;month_index<key_mortgage.payments.length;month_index++){ // iterates through every month constructing data series,
					var new_datum = [new Date(key_mortgage.payments[month_index].pay_date), key_mortgage.running_balances[month_index]];
					$scope.mortgage_chart_prep[0].values.push(new_datum);
				}
				for (month_index=0;month_index<fortune_mortgage.payments.length;month_index++){
					var new_datum = [];
					new_datum.push(new Date(fortune_mortgage.payments[month_index].pay_date));
					new_datum.push(fortune_mortgage.running_balances[month_index]);
					$scope.mortgage_chart_prep[1].values.push(new_datum);					
				}
				$scope.mortgage_chart_data.push($scope.mortgage_chart_prep[0]);
				$scope.mortgage_chart_data.push($scope.mortgage_chart_prep[1]);  // when finished with the last month, tacks the series onto a permanent site, and starts again
				console.log("mortgage chart data:");
				console.log($scope.mortgage_chart_data);
			}
		});
		/*

					//	if (month_index === (these_payments.length - 1)){
					//		chart_series.values = this_series_data;
						//console.log("starting month_index " + month_index);
				//for (this_index=0;this_index<$scope.mortgage_index.length;this_index++){ // yeah "this_index" is vague, but my usual scheme would be to call it "mortgage_index", which obviously wouldn't work here.
				//	var this_mortgage = $scope.mortgage_index.pop();
				//	console.log("after pop:");
				//	console.log($scope.mortgage_index);
				//	chart_series.key = this_mortgage.name;
				//	chart_series.color = series_colors[chart_series.key];				this for loop has been impossible to coordinate.  this_index is always max value.
						//dataset: $scope.mortgage_index[this_index].name, 
						//color: series_colors[this_index],
						//key: $scope.mortgage_index[this_index].name, 
						//label: "Remaining Balance", 
						//type: "line"
					//this_series_data = [{x: new Date(this_mortgage.initial_date), "balance": this_mortgage.initial_balance}];
					//these_payments = this_mortgage.payments;			//if (this_index === ($scope.mortgage_index.length -1)){ // if done iterating through all the mortgages
								//$scope.chart_options["series"] = chart_series;
								//console.log("chart_data: " + JSON.stringify($scope.chart_data));
								//console.log("chart_options: " + JSON.stringify($scope.chart_options));
							//}
					//}
					//}
				}
*/
		$scope.parse_mortgage = function(this_new_mortgage){
			$scope.parsed_mortgage.name = this_new_mortgage.name;
			$scope.parsed_mortgage.initial_date = new Date(this_new_mortgage.initial_date);
			$scope.parsed_mortgage.initial_balance = Number(this_new_mortgage.initial_balance);
			var raw_payment_list = this_new_mortgage.raw_payments.split('\n');
			$scope.parsed_mortgage.payments = [];
			$scope.parsed_mortgage.running_balances = [];
			for (i=0;i<raw_payment_list.length;i++){
				var these_payment_properties = raw_payment_list[i].split('\t');
				if (these_payment_properties.length != 4){
					userFactory.log('error', "Error in mortgage payment format: too few properties at " + these_payment_properties);
				} else if (Number(these_payment_properties[1]) != (Number(these_payment_properties[2]) + Number(these_payment_properties[3])).toFixed(2)){
					userFactory.log('error', "Error in mortgage payment property amounts at: " + these_payment_properties + ".  I don't think " + Number(these_payment_properties[1]) + " equals " + (Number(these_payment_properties[2]) + Number(these_payment_properties[3])).toFixed(2));
				} else {
					$scope.parsed_mortgage.payments.push({
						'pay_date': new Date(these_payment_properties[0]), 
						'total': Number(these_payment_properties[1]), 
						'interest': Number(these_payment_properties[2]), 
						'principal': Number(these_payment_properties[3])
					});
					if ($scope.parsed_mortgage.running_balances.length === 0){			
						$scope.parsed_mortgage.running_balances.push(($scope.parsed_mortgage.initial_balance - $scope.parsed_mortgage.payments[0].principal).toFixed(2));
					} else {
						$scope.parsed_mortgage.running_balances.push(($scope.parsed_mortgage.running_balances[i-1] - $scope.parsed_mortgage.payments[i].principal).toFixed(2));
					}
				}
			}
		}
		$scope.create_mortgage = function(){
			if ($scope.parsed_mortgage === {}){
				$scope.parse_mortgage($scope.new_mortgage)
			}
			mortgageFactory.create_mortgage($scope.parsed_mortgage, function(result){
				if (result.error){
					userFactory.log("error", result.error);
				} else {
					if (result.created_mortgage){
						$scope.mortgage_index.push(result.created_mortgage);
					}
					$scope.new_mortgage = {};
					$scope.parsed_mortgage = {};
					userFactory.log("message", "Mortgage created?  Result: " + JSON.stringify(result));
				}
			})
		}
		$scope.show_mortgage = function(index){
			if (index === "new"){
				$scope.main_data = {'new': true};
			} else {
				$scope.main_data = {'show': index};
				$scope.show_this_mortgage = $scope.mortgage_index[index];
			}
		}	
	}]);
	myApp.controller('preferencesController', ['$scope', 'reportFactory', 'userFactory', 'toolFactory', function($scope, reportFactory, userFactory, toolFactory){
		$scope.admin = userFactory.admin;
		$scope.colors = {};
		$scope.new_colors = [];
		$scope.unit_transaction_reference_health = function(){
			reportFactory.reference_health(function(result){
				if (result === "ok"){
					userFactory.log('message', "Unit & Transaction references look perfect.");
				} else {
					//console.log(JSON.stringify(result));
					if (result.runaway_transactions.length > 0){
						userFactory.log('error', "" + result.runaway_transactions.length + ' transactions believe themselves owned by a different unit.  See list in console.');
						for (i=0;i<result.runaway_transactions.length;i++){
							//console.log('Transaction: ' + JSON.stringify(result.runaway_transactions[i].transaction) + " and claimant, unit " + result.runaway_transactions[i].unit_number);
						}
					}
					if (result.rejecting_units.length > 0){
						userFactory.log('error', "" + result.rejecting_units.length + ' units reject clinging transactions.  See list in console.');
						for (i=0;i<result.runaway_transactions.length;i++){
							//console.log('Unit: ' + JSON.stringify(result.rejecting_units[i].unit) + " and clingant, transaction " + JSON.stringify(result.rejecting_units[i].transaction));			
						}
					}
				}
			})
		}
		$scope.make_rainbow = function(these_criteria){
			console.log("make_rainbow called with arguments: " + JSON.stringify(these_criteria));
			console.log(these_criteria);
			toolFactory.make_rainbow(these_criteria, function(result){
				if (result.error){
					userFactory.log("error", "Rainbow failed: " + result.error);
				} else {
					console.log("result received from factory: " + JSON.stringify(result));
					$scope.new_colors = result.colors;
					console.log("new_colors is now " + JSON.stringify($scope.new_colors));
				}
			})
		}
		$scope.random_rainbow = function(count){
			var all_these_colors = [];
			for (x=0;x<count;x++){
				var this_color = [];
				for (i=0;i<3;i++){
					this_color.push(Math.floor(Math.random()*255));
					console.log("pushed and made " + this_color);
				}
				all_these_colors.push({background_color: 'rgb(' + this_color[0] + ', ' + this_color[1] + ', ' + this_color[2] + ')'});
			}
			$scope.all_these_colors = all_these_colors;
		}
		$scope.my_background = function(these_rgb){
			console.log("in my_background with arguments: " + JSON.stringify(these_rgb));
			var formatted = 'rgb(' + these_rgb.rosso + ', ' + these_rgb.verde + ', ' + these_rgb.azzuro + ')';
			console.log("converted to " + formatted);
			return {background_color: formatted};
		}
	}]);
	myApp.controller('reportsController', ['$scope', 'reportFactory', 'transactionFactory', 'unitFactory', 'userFactory', function($scope, reportFactory, transactionFactory, unitFactory, userFactory){
		$scope.date_for_sorting = transactionFactory.date_for_sorting;
		$scope.active_unit_button = "";
		$scope.admin = userFactory.admin;
		$scope.current_user = userFactory.current_user;
		$scope.chart_data = {};
		$scope.generate_report = function(this_unit_number){
			if (!this_unit_number){
				userFactory.log('error', "Please select a unit number.");
			} else {
				$scope.reported_unit = this_unit_number;
				reportFactory.full_history(this_unit_number, function(result){
					$scope.this_report = result.full_history;					
					$scope.initial_balance = result.initial_balance;
					$scope.report_chart_options = result.chart_options;
					$scope.report_chart_data = [result.chart_data];
					console.log($scope.report_chart_data);
					userFactory.log('message', 'Report on unit ' + this_unit_number + " generated.");
				})
			}
		}
		if (!$scope.admin && $scope.current_user){
			$scope.generate_report($scope.current_user);
		}
		unitFactory.numbers_index(function(unit_numbers_index){
			if (unit_numbers_index.error){
				userFactory.log('error', "Error retrieving unit numbers: " + unit_numbers_index.error);
			} else {
				$scope.unit_numbers = unit_numbers_index.unit_numbers;
			}
		})
		unitFactory.index({"deposits": true}, function(result){
			if (result.error){
				userFactory.log('error', "Error retrieving deposits: " + result.error);
			} else {
				$scope.deposit_index = result.deposit_index;
			}
		})
		reportFactory.balance_summary(function(result){
			if (result.error){
				userFactory.log('error', "Error retrieving balances summary: " + result.error);
			} else {
				$scope.these_balances = result;
				userFactory.log('message', 'Unit balance summary retrieved.');
				if (!$scope.admin && $scope.current_user){
					$scope.shareholder_balance_list = {};
					$scope.balance_total = 0;
					$scope.total_unit_count = Object.keys($scope.these_balances).length;
					for (i=0;i<$scope.total_unit_count;i++){
						if ($scope.shareholder_balance_list[String($scope.these_balances[Object.keys($scope.these_balances)[i]])]){  //complicated way of querying whether each unit's balance value is on the non-admin balance list yet.
							$scope.shareholder_balance_list[String($scope.these_balances[Object.keys($scope.these_balances)[i]])] += 1;
						} else {
							$scope.shareholder_balance_list[String($scope.these_balances[Object.keys($scope.these_balances)[i]])] = 1;
						}
						$scope.balance_total += Number($scope.these_balances[Object.keys($scope.these_balances)[i]]);
					}
				}
			}
		})
		$scope.unit_button_click = function(unit_number){
			$scope.active_unit_button = unit_number;
			$scope.generate_report(unit_number);
		}
		$scope.report_chart_options = {
			"chart": {
				"type": "lineChart",
				"height": 720,
				"width": 1025, 
				"top": 20,
				"right": 40,
				"bottom": 30,
				"left": 120
			},
			"x": function(d){ return d[0];},
			"y": function(d){ return d[1];},
			"duration": 100,
			"useInteractiveGuideline": true,
			"xAxis": {
				"showMaxMin": true,
				tickFormat: function(d){
					return d3.time.format('%x')(new Date(d));
				}
			},
			"yAxis": {
				tickFormat: function(d){
					return ("$" + d3.format(',.2f')(d/100));
				}
			},
			"zoom": {
				"enabled": false
			}
		};
		console.log($scope.report_chart_options);
	}]);
	myApp.controller('taxesController', ['$scope', 'propertyTaxFactory', 'mortgageFactory', 'userFactory', function($scope, propertyTaxFactory, mortgageFactory, userFactory){
		$scope.current_user = userFactory.current_user;
		$scope.admin = userFactory.admin;
		$scope.new_tax = {};
		$scope.new_tax_options = {};
		$scope.official_calcs = {small: [992.19,736.37,848.34,1021.00,1204.92,1274.59, 1379.46], medium: [992.19, 985.98, 1135.92, 1354.74, 1613.37, 1690.65, 1847.08], large: [992.19, 1123.27, 1294.08, 1538.30, 1838.01, 1919.49, 2104.27]};  // these are from a summary xls but they conflict with single year sheets
		propertyTaxFactory.index(function(prop_tax){
			if (prop_tax.error){
				userFactory.log('error', "Error retrieving property taxes: " + prop_tax.error);
			} else {
				$scope.property_taxes_by_attribute = prop_tax.index_by_attribute;
			}
		})
		$scope.create_tax = function(this_tax_info){
			if ($scope.new_tax_options.lost_shareholder){
				this_tax_info.units_main = {'small': [6, 7, 8, 9, 15, 16, 17, 18, 24, 25, 26, 27], 'medium': [2, 10, 11, 19, 20, 28, 29], 'large': [4, 5, 12, 14, 21, 22]};
			}
			propertyTaxFactory.create_tax(this_tax_info, function(creation_result){
				if (creation_result.error){
					userFactory.log('error', "Error creating tax year: " + creation_result.error);
				} else {
					$scope.property_taxes_by_attribute = creation_result.index_by_attribute;
				}
			})
		}
		$scope.delete_tax = function(this_tax_id){
			propertyTaxFactory.delete_tax(this_tax_id, function(deletion_result){
				if (deletion_result.error){
					userFactory.log('error', "Error deleting tax year: " + deletion_result.error);
				} else {
					$scope.property_taxes_by_attribute = deletion_result.index_by_attribute;
				}
			})
		}
	}]);
	myApp.controller('transactionsIndexController', ['$scope', '$filter', 'filterFactory', 'transactionFactory', 'unitFactory', 'userFactory', function($scope, $filter, filterFactory, transactionFactory, unitFactory, userFactory){
		$scope.edit_lock = {type: false, id: null};
		$scope.updated_transaction = {};
		$scope.proposed_filters = filterFactory.proposed_filters;
		if (filterFactory.saved_filters){
			filterFactory.saved_filters.restore($scope.proposed_filters);
		}
		$scope.active_filters = filterFactory.placeholder_filters;
		$scope.unit_buttons = [];
		$scope.type_buttons= [];
		var bump_tell_count_tic = function(){  //for loop indexer slightly modified to be a unit-number iterator for times when it's just not worth the asynchrony trouble to do a server call.
			var start_index = 0;
			var bump = function(bump_tell_count){
				if (bump_tell_count === 'reset'){
					start_index = 0;
					return ("ok");
				} else if (start_index > 29){
					//console.log("Error: bump_tell_count_tic is being forced to iterate too high");
					return ({error: "No mure units to iterate"});
				} else if (bump_tell_count == "tell" && start_index === 29){
					//console.log("bump_tell_count_tic has reached the last unit");
					return (start_index);
				} else if (bump_tell_count == "tell"){
					return (start_index);
				} else if (bump_tell_count == "count"){
					return 27;
				} else if (bump_tell_count == "bump" && (start_index === 12 || start_index === 22)){
					return (start_index += 2);
				} else if (bump_tell_count == "bump" && (start_index === 29)){
					return (start_index = 1);
				} else if (bump_tell_count == "bump"){
					return (start_index += 1);
				}
			}
			return bump;
		}();
		var transaction_types = transactionFactory.allowed_types;
		$scope.or_filter = function(this_column_value, criteria){ // criteria should be a single-key object with values as a list (i.e. {unit: [7,8]})
			//console.log("Or_filter called comparing " + JSON.stringify(this_column_value) + " with " + JSON.stringify(criteria));
			var match = false;
			if (criteria.length < 1){
				//console.log("Skipping filter of " + JSON.stringify(this_column_value) + " because " + JSON.stringify(criteria) + " is empty");
				//console.log(JSON.stringify($scope.proposed_filters));
				return true;
			} else {
				for (term_index=0; term_index<criteria.length;term_index++){
					if (this_column_value === criteria[term_index]){  // if the key-designated column in the transaction is an exact match with any item in the criteria list
						match = true;
						//console.log("I think " + this_transaction[Object.keys(criteria)[0]] + " equals " + criteria[Object.keys(criteria)[0]][term_index]);
					}
					//console.log("I think " + this_transaction[Object.keys(criteria)[0]] + " does NOT equal " + criteria[Object.keys(criteria)[0]][term_index]);
				}
			}
			return match;
		}
		//var unit_numbers = unitFactory.numbers_index;
		for (i=0;i<bump_tell_count_tic("count");i++){
			$scope.unit_buttons.push({name: bump_tell_count_tic('bump'), label: bump_tell_count_tic('tell'), button_type: "unit"});
			//console.log("Unit button born: " + JSON.stringify($scope.unit_buttons[($scope.unit_buttons.length -1)]));
		}
		$scope.type_translations = {'dues': 'dues', 'credit': 'credits', 'late_fee': 'late fees', 'other_fee': 'other fees', 'assessment': 'assessments'};
		for (i=0;i<transaction_types.length;i++){
			$scope.type_buttons.push({name: transaction_types[i], label: $scope.type_translations[transaction_types[i]], button_type: "type"});
			//console.log("Type button born: " + JSON.stringify($scope.type_buttons[($scope.type_buttons.length -1)]));
		}
		$scope.apply_filters = function(){
			//console.log("transactions controller apply filters method activated");
			$scope.proposed_filters.activate($scope.active_filters);
			filterFactory.saved_filters = $scope.active_filters;
			//console.log("proposed filter status: " + JSON.stringify($scope.proposed_filters));
			//console.log("active filter at end of filter application: " + JSON.stringify($scope.active_filters));
		}
		$scope.toggle_proposed_filter = function(attribute, value){
			if (attribute === "unit" || attribute === "type"){
				if (!$scope.proposed_filters[attribute]){
					$scope.proposed_filters[attribute] = [];
				}
				var value_index = $scope.proposed_filters[attribute].indexOf(value);
				if (value_index === -1){
					$scope.proposed_filters[attribute].push(value);
				} else {
					$scope.proposed_filters[attribute].splice(value_index, 1);
					if ($scope.proposed_filters[attribute].length === 0){
						$scope.proposed_filters[attribute] = false;
					}
				}
			}
		}
		transactionFactory.index(function(factory_response){
			//console.log("transactions index controller has called transaction factory index");
			$scope.transactions_and_dues_index = factory_response.transactions_and_dues_index; 
		});
		$scope.date_for_sorting = transactionFactory.date_for_sorting;
		$scope.sort_criterion = "-date";
		var reverse_sort_strings = {
			"date": "-date", 
			"-date" : "date", 
			"_unit.number": "-_unit.number", 
			"-_unit.number": "_unit.number", 
			"amount": "-amount", 
			"-amount": "amount", 
			"check_number": "-check_number", 
			"-check_number": "check_number", 
			"type": "-type", 
			"-type": "type", 
			"notes": "-notes", 
			"-notes": "notes"
		}
		//console.log("proposed filter status: " + JSON.stringify($scope.proposed_filters));
		$scope.sort_by = function(new_criterion){
			if (new_criterion.search($scope.sort_criterion) != -1){ //if user is just reversing the sort order
				$scope.sort_criterion = reverse_sort_strings[$scope.sort_criterion];
			} else {  // if user is sorting by a new column
				$scope.sort_criterion = new_criterion;
			} 
		}
		$scope.cancel = function(){
			$scope.edit_lock = {type: false, id: null};
			$scope.updated_transaction = {};
			userFactory.log('message', 'Action canceled.');
		}
		$scope.edit_transaction = function(this_transaction){
			$scope.updated_transaction = {
				_id: this_transaction._id, 
				_unit: this_transaction._unit, 
				date: this_transaction.date, 
				type: this_transaction.type, 
				amount: (this_transaction.amount / 100).toFixed(2), 
				check_number: this_transaction.check_number, 
				notes: this_transaction.notes
			};
			$scope.edit_lock = {type: "edit", id: this_transaction._id};
			userFactory.log('message', 'Transaction prepped for editing.');
		}
		$scope.update_transaction = function(updated_transaction, transaction_id){
			transactionFactory.update(updated_transaction, function(result){
				if (result.error){
					userFactory.log('error', "Update error: " + result.error);
				} else {
					userFactory.log("message", "Update completed.  About to refresh transactions.");
					transactionFactory.index(function(factory_response){
						$scope.transactions_and_dues_index = factory_response.transactions_and_dues_index; // depending on context, this will be an object with any of these:  message: string, filtered_transactions: array, sums: {sum: Number, running_balances: list}
					});
				}
			})
			$scope.edit_lock = {type: false, id: null};
			$scope.updated_transaction = {};
		}
		$scope.prepare_delete = function(id){
			$scope.edit_lock = {type: "delete", id: id};
		}
		$scope.delete_transaction = function(this_transaction, this_unit){
			transactionFactory.delete_one(this_transaction._id, function(result){
				if (result.error){
					userFactory.log('error', "Error deleting transaction: " + result.error);
				} else {
					transactionFactory.index(function(factory_response){
						$scope.transactions_and_dues_index = factory_response.transactions_and_dues_index;
					});
					$scope.edit_lock = {type: false, id: null};
					userFactory.log('message', "Transaction deleted.  Server response: " + JSON.stringify(result.result));
				}
			})
		}
	}]);
	myApp.controller('transactionsNewController', ['$scope', 'transactionFactory', 'unitFactory', 'userFactory', function($scope, transactionFactory, unitFactory, userFactory){
		$scope.display_prep = {};
		$scope.allowed_types = transactionFactory.allowed_types;
		$scope.delete_confirmation_pending = false;
		$scope.clear_check_number = function(){
			if ($scope.new_transaction.type != "credit"){
				$scope.new_transaction.check_number = "";
			}
		}
		unitFactory.numbers_index(function(data){
			if (data.error){
				userFactory.log('error', "Error retrieving unit numbers: " + data.error);
			} else {
				$scope.unit_list = data.unit_numbers;
			}
		})
		$scope.add_tab = function(){
			$scope.update_input = $scope.update_input + "\t";
			$scope.$broadcast("tab_added");
			//console.log("should have broadcast tab_added");
		}
		$scope.delete_all = function(){
			$scope.delete_confirmation_pending = false;
			transactionFactory.delete_all(function(result){
				if (result.error){
					userFactory.log('error', "Error while mass deleting: " + JSON.stringify(result.error));
				} else {
					userFactory.log('message', "All transactions deleted.  Server response: " + JSON.stringify(result));
				}
			})
		}
		$scope.prepare_update = function(){
			var raw_update = {};
			raw_update.lines = $scope.update_input.split('\n');
			for (i=0; i<raw_update.lines.length; i++){
				raw_update.lines[i] = raw_update.lines[i].split('\t');
			}
			if (raw_update.lines.length < 2){
				userFactory.log('error', "Update must contain at least 2 lines.");
			} else {
				$scope.display_prep = raw_update.lines;
				userFactory.log('message', "New transactions prepared for upload.");
			}
		}
		$scope.create_transactions = function(){
			transactionFactory.create_transactions($scope.display_prep, function(data){
				if (data.error){
					userFactory.log("error", "Error uploading transactions: " + data.error);
				} else {
					userFactory.log("New transactions uploaded.  Server response: " + JSON.stringify(data.result));
				}
			})
		}
		$scope.create_transaction = function(new_payment){
			transactionFactory.create_transaction(new_payment, function(data){
				if (data.error){
					userFactory.log('error', 'Error creating transaction: ' + data.error);
				} else {
					/*var used_date = $scope.new_transaction.date;
					used_date = new Date(used_date);
					if (used_date.getMonth() < 12){
						//console.log("About to add month");
						used_date.setMonth(used_date.getMonth() + 1); 
						//console.log("Added month: " + used_date);
					}
					$scope.$apply($scope.new_transaction.date = used_date.toLocaleDateString());*/
					$scope.saved_transaction = data.saved_transaction;
					userFactory.log("message", 'Transaction created.');
				}
			})
		}
	}]);
	myApp.controller('unitsController', ['$scope', 'unitFactory', 'userFactory', function($scope, unitFactory, userFactory){
		unitFactory.index({populate: true}, function(these_units){
			if (these_units.error){
				userFactory.log('error', "Error retrieving unit index: " + these_units.error);
			} else {
				$scope.unit_index = these_units.index;
			}
		})
		$scope.create = function(new_unit){
			unitFactory.create(new_unit, function(new_index){
				if (new_index.error){
					userFactory.log('error', "Error creating unit: " + new_index.error);
				} else {
					$scope.unit_index = new_index.index;
					userFactory.log('message', "Unit created");
				}
			})
		}
		$scope.update = function(this_unit){
			unitFactory.update(this_unit, function(new_index){
				if (new_index.error){
					userFactory.log('error', "Error updating unit: " + new_index.error);

				} else {
					$scope.unit_index = new_index.index;
					userFactory.log('message', "Unit updated.");
				}
			})
		}
	}]);
			//for (z=0;z<this_new_history.dates.length;z++){
			//	this_new_history.dates[z] = new Date(this_new_history.dates[z]);
			//}
			//var these_balances = {
			//	dates: this_new_history.dates,
			//	values: this_new_history.values
			//};
			/*for (x=0;x<these_balances.length;x++){
				if (these_balances.values.length < 2000){
					these_balances.dates[0] = new Date("12/31/2006"); // some of them have transactions on 1/1/07 that I don't want collapsed into initial value.
					console.log("convert_to_daily is about to start iterating through " + these_balances.dates.length + " dates");
					for (y=1;y<these_balances.dates.length;y++){
						var this_date = new Date(these_balances.dates[y]);
						var this_value = these_balances.values[y];
						var last_date = new Date(these_balances.dates[y-1]);
						var last_value = these_balances.values[y-1];
						console.log("comparing " + this_date + " to " + last_date);
						if (this_date.getDate() === last_date.getDate()){					// if a date is repeated
							console.log("and decided they're the same date");
							these_balances.dates.splice(y-1, 1);		// only keep the last one.  Be careful of index shift though
							these_balances.values.splice(y-1, 1);
							y--;
						} else if (last_date.setDate(last_date.getDate() + 1) < this_date){	// remember that last_date is now +1
							these_balances.dates.splice(y, 0, last_date);
							these_balances.values.splice(y, 0, last_value);  // but do NOT put an extra y++, since you want to use this new insertion in next comparison
						}
					}
				}
			} */
			//$scope.this_new_history = this_new_history;
			//$scope.daily_result = these_balances;
	</script>
	<script src="https://apis.google.com/js/platform.js?onload=init" async defer></script>
	<meta name="google-signin-client_id" content="544028406258-p756lflvl7dqrap03ajh3kogfmc873pf.apps.googleusercontent.com">
</head>
<body ng-app='myApp'>
 	<div ng-view></div>
</body>