
<!DOCTYPE HTML>
<html>
<head>
	<title>Wilana Calc</title>
	<link rel='stylesheet' type='text/css' href='./static/style.css'>
	<script type="text/javascript" src="./angular.js"></script>
	<script type="text/javascript" src="./angular-route-1_5_5.js"></script>
	<script type="text/javascript" src="./isaac.js"></script>
	<script type="text/javascript" src="./bcrypt.js"></script>
	<script>
	var myApp = angular.module("myApp", ['ngRoute']);

	myApp.config(function($routeProvider){
		$routeProvider
			.when('/', {
				templateUrl: './partials/welcome.html'
			})
			.when('/login', {
				templateUrl: './partials/welcome.html'
			})
			.when('/matrix', {
				templateUrl: './partials/matrix_show.html'
			})
			.when('/reports', {
				templateUrl: './partials/reports.html'
			})
			.when('/transactions/new', {
				templateUrl: './partials/transactions_new.html'
			})
			.when('/transactions', {
				templateUrl: './partials/transactions_index.html'
			})
			.when('/units', {
				templateUrl: './partials/units_index_new_edit.html'
			})
			.otherwise({
				redirectTo: '/partials/welcome.html'
			});
	});
	myApp.factory('userFactory', ['$http', function($http){
		var factory = {};
		var this_seed = new Date();
		var these_milliseconds = this_seed.getTime();
		isaac.seed(these_milliseconds);
		var bcrypt = dcodeIO.bcrypt;
		bcrypt.setRandomFallback(isaac.prng);
		factory.message_log = [];
		factory.current_user = ""; //is currently used several placs to verify login status and should be made more secure
		factory.current_pw = "";
		factory.register = function(user_info, callback){
			$http.post('/users/register', user_info).success(function(result){
				callback(result);
			})
		}
		factory.login = function(credentials, callback){
			$http.post('/users/login', credentials).success(function(result){
				if (result.logged_in){
					factory.current_user = result.unit;
					factory.current_pw = credentials.pw;
				}
				callback(result);
			})
		}
		factory.logout = function(unit, callback){
			$http.post('/users/logout', unit).success(function(result){
				if (result.logged_out === true){
					factory.current_user = "";
					factory.current_pw = "";
				}
				callback(result);
			})
		}
		factory.update_user = function(updated_user, callback){
			updated_user.unit = factory.current_user;
			updated_user.online = true;
			var update_user_path = 'users/' + factory.current_user + '/update';
			$http.post(update_user_path, {updated_user: updated_user}).success(function(result){
				if (result.result){
					factory.current_pw = updated_user.pw_hash;
				}
				callback(result);
			})
		}
		factory.logout_many = function(users, callback){ //not ideal, but currently anticipates that users is a list of user objects
			var this_index = function(){
				var current_index = -1;
				var increment = function(bump_or_tell){
					if (bump_or_tell === "bump"){
						current_index += 1;
						return current_index; //this appears to increment after sending value.
					} else if (bump_or_tell === "tell"){
						return current_index;
					}
				}
				return increment;
			}();
			var logged_out = [];
			//console.log("users: " + JSON.stringify(users));
			var admin_index = users.indexOf({unit: "Admin"});
			if (admin_index != -1){
				users.splice(admin_index, 1);
				//console.log("spliced out admin: " + JSON.stringify(users));
			}
			//console.log("starting user loops: " + JSON.stringify(users));;
			for (i=0; i<users.length; i++){
				if (users[i].unit != "Admin"){
					factory.logout({unit: users[this_index('bump')].unit}, function(result){
						//console.log("logout result: " + JSON.stringify(result));
						if (result.error){
							callback(result);
						} else if (result.logged_out){
							logged_out.push(result.unit);
							if (logged_out.length === users.length){
								callback ({result: true, logged_out: logged_out});
							} else {
								//console.log("not yet time to send mass logout response: " + users.length, + ", " + logged_out.length);
							}
						}
					})
				} else {
					this_index('bump');
				}
			}
		}
		factory.index = function(callback){
			$http.post('/users').success(function(data){
				////console.log("Factory user index received result: " + JSON.stringify(data));
				data.users.sort(function(a,b){
					if (a.unit == "Admin"){
						return 1;
					} else if (b.unit == "Admin"){
						return -1;
					} else {
						return (Number(a.unit) - Number(b.unit));
					}
				})
				callback(data);
			})
		}
		factory.log = function(action, message){  // can take 3 styles & numbers of arguments.  To add a message: ('error' or 'message' (whichever is relevant), message text).  to clear: ('clear').  to just retrieve log: ().
			if ((action === 'error' || action === 'message') && (typeof message === "string")){
				factory.message_log.unshift({type: action, date: (new Date(Date.now()).toLocaleTimeString()), text: message});
			} else if (action === 'clear'){
				console.log('Clearing message log');
				factory.message_log = [];
			}
			//console.log("Current message log: " + JSON.stringify(factory.message_log));
			return factory.message_log;
		}
		return factory;
	}]);
	myApp.factory('matrixFactory', ['$http', function($http){
		var factory = {};
		factory.index = function(callback){
			$http.get('/dues_matrixes').success(function(data){
				formatted_data = {};
				if (data.error){
					formatted_data = data;
				} else {
					for (i=0; i<data.rates.length; i++){
						if (data.rates[i][0] != null){
							formatted_data[i] = data.rates[i];  //reformats matrix as {1: [320,null,null,335...], {2: [320,null,null,335...]} for ng-repeat
						}
					}
				}
				callback(formatted_data);
			})
		};
		return factory;
	}]);
	myApp.factory('transactionFactory', ['$http', function($http){
		var factory = {};
		factory.allowed_types = ['credit', 'assessment', 'late_fee', 'other_fee', 'dues'];
		factory.index = function(callback){
			$http.post("/transactions").success(function(data){
				var index_by_unit = {};
				for (i=0;i<data.index.length;i++){
					var this_transaction = data.index[i];
					this_transaction.unit = this_transaction._unit.number;
					var this_unit = String(this_transaction._unit.number);
					//console.log("this transaction.date is a " + (typeof this_transaction.date) + " and contains " + this_transaction.date);
					this_transaction.date = new Date(this_transaction.date).toLocaleDateString();
					//console.log("the new improved date: " + this_transaction.date);
					if (!index_by_unit[this_unit]){
						index_by_unit[this_unit] = [];
					}
					index_by_unit[this_unit].push(this_transaction);
				}
				callback({index: data.index, index_by_unit: index_by_unit});
			})
		}
		factory.create_transactions = function(credit_chart, callback){  //see update_dues partial for formatting instructions
			var transaction_count = 0;
			var row_index = function(){
				var start_index = 0;
				var bump = function(bump_or_tell){
					if (bump_or_tell == "bump"){
						return(start_index += 1);
					} else if (bump_or_tell == "tell"){
						return (start_index);
					}
				}
				return bump;
			}();
			for(row=1; row<credit_chart.length; row++){					
				var date_list_for_chopping = [];
				for (date_index=0; date_index < credit_chart[0].length; date_index++){  //if I just say chopping = creditchart0, it passes by reference.
					date_list_for_chopping.push(credit_chart[0][date_index]);
				}
				for(col=1; col<credit_chart[row].length; col++){
					var this_amount = Number(credit_chart[row][col]);
					credit_chart[row][col] = {amount: this_amount, date: date_list_for_chopping[col], _unit: credit_chart[row][0], type: "credit", check_number: "", notes: ""};
					if (credit_chart[row][col].amount === 0 || !credit_chart[row][col].amount){
						credit_chart[row].splice(col, 1);
						date_list_for_chopping.splice(col, 1);
						console.log("Spliced out credit_chart coordinates " + row + ", " + col);
						col -= 1;
					}
				}
				transaction_count += credit_chart[row].length - 1;
				$http.post('/transactions/createMany', {credit_row: credit_chart[row_index("bump")]}).success(function(data){
					callback(data);
				})
			}
			console.log("# transactions: " + transaction_count);
		}
		factory.create_transaction = function(new_transaction, callback){
			$http.post('/transactions/createOne', {new_transaction: new_transaction}).success(function(data){
				callback(data);
			})
		}
		factory.update = function(updated_transaction, callback){
			var update_path = "/transactions/" + updated_transaction._id + "/update";
			//delete updated_transaction.unit;
			//delete updated_transaction._id;
			$http.post(update_path, {updated_transaction: updated_transaction}).success(function(data){
				console.log("Factory received what should be updated transaction from server: " + JSON.stringify(data));
				callback(data);
			})
		}
		factory.delete_one = function(id, callback){
			var delete_path = "/transactions/" + id + "/delete";
			$http.post(delete_path).success(function(result){
				callback(result);
			})
		}
		factory.delete_all = function(callback){
			$http.post("/transactions/deleteMany").success(function(result){
				callback(result);
			})
		}
		factory.date_for_sorting = function(transaction){
			var this_date = new Date(transaction.date);
			return this_date;
		}
		return factory;
	}]);
	myApp.factory('unitFactory', ['$http', 'userFactory', function($http, userFactory){
		var factory = {};
		factory.numbers_index = function(callback){
			$http.get('/unit_numbers_index').success(function(data){
				if (data.error){
					callback({error: data.error});
				} else {
					var unit_numbers = [];
					for (i=0; i<data.unit_numbers.length; i++){
						unit_numbers.push(data.unit_numbers[i].number);
					}
					callback({unit_numbers: unit_numbers}); // is just a raw list of numbers.  no IDs or objects.
				}
			});
		}
		factory.index = function(options, callback){ // options is currently either {populate: true} or {populate: false}
			$http.post('/units', {options: options, credentials: {unit: userFactory.current_user, pw: userFactory.current_pw}}).success(function(data){
				if (data.index){
					for (i=0; i<data.index.length; i++){
						data.index[i].initial_balance_string = data.index[i].initial_balance.toFixed(2);
					}
				}
				callback(data);
			});
		}
		factory.create = function(new_unit, callback){
			$http.post('/units/create', new_unit).success(function(data){
				if (data.error){
					callback(data);
				} else {
					factory.index(function(these_units){
						callback(these_units);
					})
				}
			});
		}
		factory.update = function(updated_unit, callback){
			var update_path = '/units/'+updated_unit._id+'/update'
			$http.post(update_path, updated_unit).success(function(data){
				if (data.error){
					callback(data);
				} else {
					factory.index(function(these_units){
						callback(these_units);
					})
				}
			});
		}
		return factory;
	}]);
	myApp.factory('reportFactory', ['$http', '$filter', 'filterFactory', 'unitFactory', 'transactionFactory', function($http, $filter, filterFactory, unitFactory, transactionFactory){
		var factory = {};
		var transaction_index = [];
		factory.filtered_transactions = [];
		transactionFactory.index(function(data){
			transaction_index = data.index;
			console.log("got transaction index, length" + transaction_index.length + ", " + JSON.stringify(transaction_index.slice(0,1)));
		})
		var re_filter = function(transaction_list){
				console.log("In re_filter, starting with index size " + transaction_list.length + "Query will be: $filter('in_group')({'item_list':" + transaction_list + ", 'group': " + filterFactory.get('unit') + ", 'property': 'unit'}); ");
				var once_filtered = $filter('in_group')({'item_list': transaction_list, 'group': filterFactory.get('unit'), 'property': 'unit'}); 
				console.log("once_filtered has been reduced to " + once_filtered.length + " & will now be filtered by " + filterFactory.get('type'));
				var re_filtered_transactions = $filter('in_group')({'item_list': once_filtered, 'group': filterFactory.get('type'), 'property': 'type'});
				return re_filtered_transactions;
		}
		factory.reference_health = function(callback){
			var runaway_transactions = [];
			var rejecting_units = [];
			transactionFactory.index(function(trans_data){
				var sick_transaction_list = trans_data.index;
				unitFactory.index({populate: false}, function(unit_data){
					var sick_unit_list = unit_data.index;
					console.log("Commencing reference check on " + sick_unit_list.length + " units and " + sick_transaction_list.length + " transactions.");
					var comparison_count = 0;
					var this_unit = {};
					var this_transaction = {};
					for (var unit_index = 0;unit_index<sick_unit_list.length;unit_index++){
						for (var trans_index=0; trans_index<sick_transaction_list.length; trans_index++){
							comparison_count++;
							this_unit = sick_unit_list[unit_index];
							this_transaction = sick_transaction_list[trans_index];
							if (this_transaction._unit._id === this_unit._id){ // if this transaction thinks it has found its mother unit
								if (this_unit.transactions.indexOf(this_transaction._id) === (-1)){ //but the mother thinks it's a stranger
									rejecting_units.push({"unit": this_unit, "transaction": this_transaction});
								}
							}
							if (this_unit.transactions.indexOf(this_transaction._id) != (-1)){ // if this trans is on the unit's trans list
								if (this_transaction._unit._id != this_unit._id){ // but the transaction thinks it belongs elsewhere
									runaway_transactions.push({"transaction": this_transaction, "unit_number": this_unit.number});
								}
							}
						}
					}
					console.log("Finished " + comparison_count + "comparisons of " + sick_unit_list.length + " units and " + sick_transaction_list.length + " transactions. About to return report");
					if (runaway_transactions.length + rejecting_units.length === 0){
						callback("ok");
					} else {
						callback({runaway_transactions: runaway_transactions, rejecting_units: rejecting_units});
					}
				});
			});
		};
		factory.update_report = function(reason, callback){
			if (filterFactory.filter_count > 0){
				console.log("update_report decided are enough active filters: " + filterFactory.filters_active + " to continue processing update");
				if (reason === "transaction_change"){
					transactionFactory.index(function(data){
						if (data === false){
							//console.log("update_report got the idea that new index data is false.  I have no idea why it even checks");;
							callback([]);
						} else if (data.index){
							transaction_index = data.index;
							console.log("reportFactory retrieved new base transaction_list after receiving notice of change. length: " + transaction_index.length);
							factory.filtered_transactions = re_filter(transaction_index);
							console.log('Factory is about to return re-filtered transactions to controller.  length: ' + factory.filtered_transactions.length);
							callback(factory.filtered_transactions);
						}
					})
				} else {
					console.log("Decided only a re-filter was necessary");
					factory.filtered_transactions = re_filter(transaction_index);
					callback(factory.filtered_transactions);
				}
			} else {
				console.log("update_report decided there are no active filters and so returned an empty list");
				callback([]);
			}
		}
		factory.balance_summary = function(callback){
			unitFactory.numbers_index(function(unit_numbers_index){
				if (unit_numbers_index.error){
					callback(unit_numbers_index);
				} else {
					var these_units = unit_numbers_index.unit_numbers;
					var these_balances = {};
					for(i=0; i<these_units.length;i++){
						factory.full_history(these_units[i], function(this_history){
							these_balances[this_history.unit] = this_history.current_balance;
							console.log("added a unit to balance summary.  Summary now has " + Object.keys(these_balances).length + " units.  Object: " + JSON.stringify(these_balances));
							if (Object.keys(these_balances).length === unit_numbers_index.unit_numbers.length){
								console.log("returning balance summary to controller");
								callback(these_balances);
							} else {
								console.log("Chose not to return summary of length " + Object.keys(these_balances).length + " because it is less than " + unit_numbers_index.unit_numbers.length);
							}
						})
					}
				}
			})
		}
		factory.full_history = function(unit, callback){
			var today = new Date();
			var months = (today.getFullYear() - 2011) * 12 + today.getMonth() + 1;
			var show_route = '/units/' + unit;
			var this_full_history = {transactions: [], balances: []};
			$http.post('/trim_matrix', {unit: unit, months: months}).success(function(matrix_result){
				//console.log("In trim-matrix callback in full_history method");
				var these_dues = [];
				var these_payments = [];
				var these_assessments = [];
				var these_fees = [];
				var dues_date = new Date('12/01/2010');
				for (i=0; i<matrix_result.dues_list.length; i++){
					these_dues.push({date: dues_date.setMonth(dues_date.getMonth() + 1), amount: matrix_result.dues_list[i], type: "dues"})
				}
				$http.post(show_route).success(function(unit_result){
					//console.log("In units/show callback in full_history method: " + JSON.stringify(unit_result));
					these_transactions = unit_result.unit.transactions;
					for (i=0; i<these_transactions.length; i++){
						these_transactions[i].amount = (these_transactions[i].amount / 100);
					}
					var this_history = these_dues.concat(these_transactions);
					for(i=0; i<this_history.length; i++){
						this_history[i].date = new Date(this_history[i].date);
						this_history[i].date = this_history[i].date.toLocaleDateString();
					}
					this_history.sort(function(a,b){return new Date(a.date) - new Date(b.date)});
					var previous_balance = unit_result.unit.initial_balance;
					for(i=0; i<this_history.length; i++){
						if (this_history[i].type === 'credit'){
							this_history[i].credit_amount = (this_history[i].amount).toFixed(2);
							this_history[i].charge_amount = "";
							previous_balance += Number(this_history[i].amount);
						} else {
							this_history[i].charge_amount = (this_history[i].amount).toFixed(2);
							this_history[i].credit_amount = "";
							previous_balance -= Number(this_history[i].amount);
						}
						this_full_history['balances'].push(previous_balance.toFixed(2));
						this_full_history['transactions'].push(this_history[i]);
					}
					this_full_history['balances'].reverse();
					this_full_history['transactions'].reverse();
					callback({unit: unit, full_history: this_full_history, current_balance: this_full_history['balances'][0], initial_balance: unit_result.unit.initial_balance.toFixed(2)});
				})
			})
		}
		return factory;
	}]);
	myApp.factory('filterFactory', ['$rootScope', function($rootScope){
		var factory = {};
		var filters = {};
		var filter_types = {};
		var isEmpty = function(this_object) { 
   			for (var x in this_object) { 
   				return false; 
   			}
   			return true;
   		}
   		var broadcast_prep = function(action, this_filter, this_value, callback){
   			if (action === "add"){
   				filters[this_filter][this_value] = true;  //couldn't think of a way to add to hash if present or create hash if absent without at least one if statement
				factory.filter_count += 1;
				console.log('filter ' + this_filter + ": " + this_value + " added to filter hash and filter_count is now " + factory.filter_count);
   			} else if (action === 'remove'){
				delete filters[this_filter][this_value];
				factory.filter_count -= 1;
				console.log('filter ' + this_filter + ": " + this_value + " removed.");
   			}
   			callback(factory.filter_count);
   		}
   		factory.filter_count = 0;
   		factory.get = function(this_filter){
   			if (isEmpty(filters[this_filter])){
   				console.log("determined that " + this_filter + " in " + JSON.stringify(filters) + " is empty");
   				return false;
   			} else {
   				console.log("Returning populated filter: " + JSON.stringify(filters[this_filter]));
   				return filters[this_filter];
   			}
   		}
		factory.add_filter = function(this_filter, this_value){
			if (!(this_filter in filters)){
				console.log("filterfactory is adding " + this_filter + " to " + JSON.stringify(filters));
				filters[this_filter] = {};
			}
			console.log("About to start broadcast prep by adding" + this_value + ": true to " + this_filter + " in " + JSON.stringify(filters));
			broadcast_prep("add", this_filter, this_value, function(filter_count){
				console.log("In broadcast_prep callback.  filter_count is " + filter_count + " About to broadcast & return filter values.");
				$rootScope.$broadcast('filter_updated');  // this was firing off and causing a transaction list update bfore filter_count could get incremented, so turned it into callback.
			})
			console.log("add_filter is returning " + this_filter);
			return factory.get(this_filter);
		}
		factory.remove_filter = function(this_filter, this_value){
			broadcast_prep("remove", this_filter, this_value, function(filter_count){
				console.log("In broadcast_prep callback.  filter_count is " + filter_count + "About to broadcast & return filter values or false");
				$rootScope.$broadcast('filter_updated');
				return factory.get(this_filter);
			})
		}
		return factory;
	}]);
	myApp.filter('in_group', function(){
		console.log("ingroup filter called");
		return function(parameters){   // parameters = {item_list: [x,y,z], group: [x,y]}  or {item_list: [{object}, {object}], group: {value: true, value: true}, property: 'unit_number'}
			var filtered_list = [];
			if (!parameters.group){
				//console.log("Filter determined that there is no group, which would be the case if group were false.  Item List would have been " + parameters.item_list + " long.");
				filtered_list = parameters.item_list;		// 2nd parameter will be "group: false" if that property is set to be unfiltered.  This is different from having no filters clicked, which would return []
			} else {
				for (i=0;i<parameters.item_list.length;i++){
					if (!parameters.property){ // determines whether the input list is a regular array or an array of objects
						//console.log("Filter is behaving as if it were given a list of items to filter instead of an object of them");
						if (parameters.item_list[i] in parameters.group){
							//console.log("Determined that parameters item list i: " + parameters.item_list[i] + " is in parameters group: " + parameters.group);
							filtered_list.push(parameters.item_list[i]);
						} else {
							//console.log("Filter did not think this item was 'in' this group & so culled it.  Group: " + parameters.group + ", Item: " + JSON.stringify(parameters.item_list[i]));
						}
					} else {
						//console.log("filter is behaving as if it were given an object full of things to evaluate, not a list");
						if (parameters.item_list[i][parameters.property] in parameters.group){
							filtered_list.push(parameters.item_list[i]);
						} else {
							//console.log("Filter determine that " + parameters.item_list[i][parameters.property] + " was not in " + parameters.group + " and threw it away");
						}
					}
				}
			}
			console.log("filter is returning filtered_list, length " + filtered_list.length);
			return filtered_list;
		}
	})
	myApp.controller('appController', ['$scope', '$rootScope', '$location', 'userFactory', 'reportFactory', 'transactionFactory', function($scope, $rootScope, $location, userFactory, reportFactory, transactionFactory){
		$scope.login_info = {unit: "Admin", pw: 'wilana_calc'};  //sets default login name.  remove for real use
		$scope.logged_in = false;
		$scope.logout_result = "";
		$scope.updated_transaction = [];
		$scope.new_user = {};
		$scope.user_list = [];
		$scope.user_info = {};
		$scope.current_user = userFactory.current_user;
		$scope.edit_user = false;
		$scope.updated_user = {};
		$scope.report = "";
		$scope.today = new Date();
		$scope.date_for_sorting = transactionFactory.date_for_sorting;
		$scope.message_log = userFactory.message_log;
		$scope.page_titles = {
			'/': "User Login", 
			'/matrix': "Dues Matrix", 
			'/reports': "Unit Reports", 
			'/transactions': "Transactions Index", 
			'/transactions/new': "New Transaction(s) Entry", 
			'/units': "Unit Index", 
			'/login': "User Login"};
		$scope.this_page_title = $scope.page_titles[$location.url()];
		$scope.location = $location.url();
		userFactory.index(function(user_index){
			if (user_index.error){
				userFactory.log('error', "Error retrieving user list: " + user_index.error);
			} else {			
				$scope.user_list = user_index.users;
			}
		})
		$scope.clear_log = function(){
			$scope.$evalAsync(userFactory.log("clear"));
		}
		$scope.refresh_log = function(){
			$scope.$evalAsync(userFactory.log());
		}
		$scope.unit_transaction_reference_health = function(){
			reportFactory.reference_health(function(result){
				if (result === "ok"){
					userFactory.log('message', "Unit & Transaction references look perfect.");
				} else {
					console.log(JSON.stringify(result));
					if (result.runaway_transactions.length > 0){
						userFactory.log('error', "" + result.runaway_transactions.length + ' transactions believe themselves owned by a different unit.  See list in console.');
						for (i=0;i<result.runaway_transactions.length;i++){
							console.log('Transaction: ' + JSON.stringify(result.runaway_transactions[i].transaction) + " and claimant, unit " + result.runaway_transactions[i].unit_number);
						}
					}
					if (result.rejecting_units.length > 0){
						userFactory.log('error', "" + result.rejecting_units.length + ' units reject clinging transactions.  See list in console.');
						for (i=0;i<result.runaway_transactions.length;i++){
							console.log('Unit: ' + JSON.stringify(result.rejecting_units[i].unit) + " and clingant, transaction " + JSON.stringify(result.rejecting_units[i].transaction));			
						}
					}
				}
			})
		}
		$scope.register = function(user_info){
			userFactory.register(user_info, function(result){
				if (result.error){
					userFactory.log('error', "Error registering new user: " + result.error);
				} else {
					userFactory.log('message', "Registration completed.");
					$location.url('/login');
				}
			})
		}
		$scope.login = function(login_info){
			userFactory.login(login_info, function(result){
				if (result.error){
					userFactory.log('error', ("Error during login: " + result.error));
				} else if (result.admin === true){ 				//this properly redirects but does not protect other partials from being accessed.  Also  need to add easy way to change admin password  **************important to fix***********
					$scope.report = "";
					$scope.current_user = "Admin";	//useful for hiding DOM admin tools.  Block them more securely serverside too.
					$scope.logged_in = true;	//can probably be subsumed into current_user
					userFactory.log('message', "Admin login completed.");
					$location.url('/units');
				} else if (result.logged_in === true){
					$scope.logged_in = true;
					$scope.current_user = result.unit;
					$scope.display_history(result.unit);
					userFactory.log('message', "User login completed.");
				}
			})
		}
		$scope.logout = function(){
			userFactory.logout({unit: userFactory.current_user}, function(result){
				if (result.error){
					userFactory.log('error', "Error during logout: " + result.error);
				} else if (result.logged_out){
					$scope.logged_in = false;
					$scope.current_user = "";
					userFactory.log('message', "Logout completed.");
				}
			})
		}
		$scope.logoff_many = function(){
			userFactory.logout_many($scope.user_list, function(result){
				userFactory.log('message', 'Mass logout result: ' + JSON.stringify(result));;
			})
		}
		$scope.update_user = function(){
			console.log("in user factory, about to update password");
			userFactory.update_user($scope.updated_user, function(result){
				if (result.error){
					userFactory.log('error', "Error updating user: " + result.error);
				} else {
					$scope.updated_user = {};
					$scope.edit_user = false;
					userFactory.log('message', 'User update completed.  Server response: ' + result.result);
				}
			})
		}
		$scope.display_history = function(current_unit){ //current_unit at this time is just the unit number, not its objectId
			reportFactory.full_history(current_unit, function(result){  
				$scope.this_report = result.full_history;
				$scope.initial_balance = result.initial_balance;
			})	
		}
	}]);
	myApp.controller('matrixesController', ['$scope', 'matrixFactory', 'userFactory', function($scope, matrixFactory, userFactory){
		$scope.dues_matrix = [];
		$scope.index = function(){
			matrixFactory.index(function(data){
				if (data.error){
					userFactory.log('error', "Error retrieving dues rates: " + data.error);
				} else {
					$scope.dues_matrix = data;
					userFactory.log('message', 'Dues rate matrix loaded.');
				}
			})
		}
	}]);
	myApp.controller('reportsController', ['$scope', 'reportFactory', 'transactionFactory', 'unitFactory', 'userFactory', function($scope, reportFactory, transactionFactory, unitFactory, userFactory){
		$scope.date_for_sorting = transactionFactory.date_for_sorting;
		$scope.active_unit_button = "";
		unitFactory.numbers_index(function(unit_numbers_index){
			if (unit_numbers_index.error){
				userFactory.log('error', "Error retrieving unit numbers: " + unit_numbers_index.error);
			} else {
				$scope.unit_numbers = unit_numbers_index.unit_numbers;
			}
		})
		$scope.balance_summary = function(){
			reportFactory.balance_summary(function(result){
				if (result.error){
					userFactory.log('error', "Error retrieving balances summary: " + result.error);
				} else {
					$scope.these_balances = result;
					userFactory.log('message', 'Unit balance summary retrieved.');
				}
			})
		}();
		$scope.unit_button_click = function(unit_number){
			$scope.active_unit_button = unit_number;
			$scope.generate_report(unit_number);
		}
		$scope.generate_report = function(this_unit_number){
			if (!this_unit_number){
				userFactory.log('error', "Please select a unit number.");
			} else {
				$scope.reported_unit = this_unit_number;
				reportFactory.full_history(this_unit_number, function(result){
					$scope.this_report = result.full_history;
					$scope.initial_balance = result.initial_balance;
					userFactory.log('message', 'Report on unit ' + this_unit_number + " generated.");
				})
			}
		}
	}]);
	
	myApp.controller('transactionsIndexController', ['$scope', '$filter', 'reportFactory', 'transactionFactory', 'userFactory', function($scope, $filter, reportFactory, transactionFactory, userFactory){
		$scope.edit_lock = {type: false, id: null};
		$scope.updated_transaction = {};	
		$scope.filtered_transactions = reportFactory.filtered_transactions;
		$scope.allowed_types = transactionFactory.allowed_types;
		$scope.date_for_sorting = transactionFactory.date_for_sorting;
		console.log('buttonscontroller f-t length is ' + $scope.filtered_transactions.length);
		$scope.$on('filter_updated', function(){
			console.log("TransactionsIndex/ButtonsController heard about a filter update and is ordering an updated transaction list");
			reportFactory.update_report("filter_change", function(filtered_list){
				$scope.filtered_transactions = filtered_list;
				console.log("buttonsController has received an updated filtered transaction list, length: " + $scope.filtered_transactions.length);
			});
		})
		$scope.sort_criterion = "-date_for_sorting(date)";
		var reverse_sort_strings = {"date_for_sortingh(date)": "-date_for_sorting(date)", "-date_for_sorting(date)" : "date_for_sorting(date)", "_unit.number": "-_unit.number", "-_unit.number": "_unit.number", "amount": "-amount", "-amount": "amount", "check_number": "-check_number", "-check_number": "check_number", "type": "-type", "-type": "type", "notes": "-notes", "-notes": "notes"};
		$scope.sort_by = function(new_criterion){
			if (new_criterion.search($scope.sort_criterion) != -1){
				$scope.sort_criterion = reverse_sort_strings[$scope.sort_criterion];
			} else {
				$scope.sort_criterion = new_criterion;
			} 
		}
		$scope.cancel = function(){
			$scope.edit_lock = {type: false, id: null};
			$scope.updated_transaction = {};
			userFactory.log('message', 'Action canceled.');
		}
		$scope.edit_transaction = function(this_transaction){
			$scope.updated_transaction = {
				_id: this_transaction._id, 
				_unit: this_transaction._unit, 
				date: this_transaction.date, 
				type: this_transaction.type, 
				amount: (this_transaction.amount / 100).toFixed(2), 
				check_number: this_transaction.check_number, 
				notes: this_transaction.notes
			};
			console.log("Prepped for editing: " + JSON.stringify($scope.updated_transaction));
			$scope.edit_lock = {type: "edit", id: this_transaction._id};
			userFactory.log('message', 'Transaction prepped for editing.');
		}
		$scope.update_transaction = function(updated_transaction, transaction_id){
			transactionFactory.update(updated_transaction, function(result){
				if (result.error){
					userFactory.log('error', "Update error: " + result.error);
				} else {
					userFactory.log("message", "Update completed.  About to refresh transactions.");
					reportFactory.update_report("transaction_change", function(new_index){
						$scope.filtered_transactions = new_index;
						console.log("controller has received final filterd transaction list: Here is the first: " + JSON.stringify($scope.filtered_transactions[0]));
					});
				}
			})
			$scope.edit_lock = {type: false, id: null};
			$scope.updated_transaction = {};
		}
		$scope.prepare_delete = function(id){
			$scope.edit_lock = {type: "delete", id: id};
		}
		$scope.delete_transaction = function(this_transaction, this_unit){
			transactionFactory.delete_one(this_transaction._id, function(result){
				if (result.error){
					userFactory.log('error', "Error deleting transaction: " + result.error);
				} else {
					var this_index = $scope.index_by_unit[this_unit].indexOf(this_transaction);
					$scope.index_by_unit[this_unit].splice(this_index, 1);
					$scope.edit_lock = {type: false, id: null};
					userFactory.log('message', "Transaction deleted.  Server response: " + JSON.stringify(result.result));
				}
			})
		}
	}]);
	myApp.controller('transactionsNewController', ['$scope', 'transactionFactory', 'unitFactory', 'userFactory', function($scope, transactionFactory, unitFactory, userFactory){
		$scope.display_prep = {};
		$scope.allowed_types = transactionFactory.allowed_types;
		$scope.delete_confirmation_pending = false;
		$scope.clear_check_number = function(){
			if ($scope.new_transaction.type != "credit"){
				$scope.new_transaction.check_number = "";
				console.log('new check no = ' + $scope.new_transaction.check_number);
			}
		}
		unitFactory.numbers_index(function(data){
			if (data.error){
				userFactory.log('error', "Error retrieving unit numbers: " + data.error);
			} else {
				$scope.unit_list = data.unit_numbers;
			}
		})
		$scope.delete_all = function(){
			$scope.delete_confirmation_pending = false;
			transactionFactory.delete_all(function(result){
				if (result.error){
					userFactory.log('error', "Error while mass deleting: " + JSON.stringify(result.error));
				} else {
					userFactory.log('message', "All transactions deleted.  Server response: " + JSON.stringify(result));
				}
			})
		}
		$scope.prepare_update = function(){
			var raw_update = {};
			raw_update.lines = $scope.update_input.split('\n');
			for (i=0; i<raw_update.lines.length; i++){
				raw_update.lines[i] = raw_update.lines[i].split('\t');
			}
			if (raw_update.lines.length < 2){
				userFactory.log('error', "Update must contain at least 2 lines.");
			} else {
				$scope.display_prep = raw_update.lines;
				userFactory.log('message', "New transactions prepared for upload.");
			}
		}
		$scope.create_transactions = function(){
			transactionFactory.create_transactions($scope.display_prep, function(data){
				if (data.error){
					userFactory.log("error", "Error uploading transactions: " + data.error);
				} else {
					userFactory.log("New transactions uploaded.  Server response: " + JSON.stringify(data.result));
				}
			})
		}
		$scope.create_transaction = function(new_payment){
			transactionFactory.create_transaction(new_payment, function(data){
				if (data.error){
					userFactory.log('error', 'Error creating transaction: ' + data.error);
				} else {
/*					var used_date = $scope.new_transaction.date;
					console.log("used date: " + used_date);
					used_date = new Date(used_date);
					console.log("Dated used date: " + used_date);
					if (used_date.getMonth() < 12){
						console.log("About to add month");
						used_date.setMonth(used_date.getMonth() + 1); 
						console.log("Added month: " + used_date);
					}
					console.log("before apply: new transaction " + $scope.new_transaction.date + " & used_date " + used_date.toLocaleDateString());
					$scope.$apply($scope.new_transaction.date = used_date.toLocaleDateString());
					console.log("after apply: " + $scope.new_transaction.date);	*/
					$scope.saved_transaction = data.saved_transaction;
					userFactory.log("message", 'Transaction created.');
				}
			})
		}
	}]);
	myApp.controller('unitsController', ['$scope', 'unitFactory', 'userFactory', function($scope, unitFactory, userFactory){
		unitFactory.index({populate: true}, function(these_units){
			if (these_units.error){
				userFactory.log('error', "Error retrieving unit index: " + these_units.error);
			} else {
				$scope.unit_index = these_units.index;
			}
		})
		$scope.create = function(new_unit){
			unitFactory.create(new_unit, function(new_index){
				if (new_index.error){
					userFactory.log('error', "Error creating unit: " + new_index.error);
				} else {
					$scope.unit_index = new_index.index;
					userFactory.log('message', "Unit created");
				}
			})
		}
		$scope.update = function(this_unit){
			unitFactory.update(this_unit, function(new_index){
				if (new_index.error){
					userFactory.log('error', "Error updating unit: " + new_index.error);

				} else {
					$scope.unit_index = new_index.index;
					userFactory.log('message', "Unit updated.");
				}
			})
		}
	}]);
	myApp.controller('filtersController', ['$scope', '$rootScope', '$filter', 'reportFactory', 'unitFactory', 'filterFactory', 'transactionFactory', function($scope, $rootScope, $filter, reportFactory, unitFactory, filterFactory, transactionFactory, transactionFilter){
		console.log("running initial filterscontroller actions");
		$scope.transaction_types = transactionFactory.allowed_types;
		$scope.transaction_labels = [];
		$scope.buttons = [];
		$scope.allowed_units = {};
		$scope.allowed_types = {};
		unitFactory.numbers_index(function(data){
			console.log("In filtercontroller numbers_index function callback");
			var previously_activated_units = filterFactory.get('unit');
			$scope.unit_numbers = data.unit_numbers;
			for (i=0;i<$scope.unit_numbers.length;i++){
				var this_filter = false;
				if (previously_activated_units && $scope.unit_numbers[i] in previously_activated_units){
					this_filter = true;
					console.log("Found a previously activated unit filter");	
				} else {
					console.log("I think " + $scope.unit_numbers[i] + " is not in " + previously_activated_units);
				}
				$scope.buttons.push({name: $scope.unit_numbers[i], label: $scope.unit_numbers[i], screen: "unit", filter: this_filter});
			}
			console.log("done with callback.  buttons: " + JSON.stringify($scope.buttons));
		})
		$scope.type_buttons= [];
		$scope.type_translations = {'dues': 'dues', 'credit': 'credits', 'late_fee': 'late fees', 'other_fee': 'other fees', 'assessment': 'assessments'};
		for (i=0;i<$scope.transaction_types.length;i++){
			$scope.type_buttons.push({name: $scope.transaction_types[i], label: $scope.type_translations[$scope.transaction_types[i]], screen: "type", filter: false});
		}	
		$scope.toggle_button = function(clicked_button){ //clicking a filter button triggers a complicated series of events:
			/* 	1) Relevant filter added/removed from master filter list in filterfactory.
				2) filterFactoyry broadcasts that a filter has updated
				3) TransactionsIndexController hears it and ordere an updated transaction list from report factoryh
				4) update_report in reportFactory checks to make sure there are active filters.  If none, returns an empty list to view.
				5) Otherwise it retrieves the full list of filters and orders them to be used by $filter and returns the filtered results to view.
			*/
			if (clicked_button.filter === false){
				//console.log("adding units, value: " + clicked_button.screen + ", " + clicked_button.label);
				filterFactory.add_filter(clicked_button.screen, clicked_button.name);
				//$scope.filtered_transactions = reportFactory.filtered_transactions;
				//$scope.filtered_transactions = $filter('in_group')({'item_list': $scope.transaction_index, 'group': filterFactory.get(clicked_button.screen), 'property': clicked_button.screen}); 
				//console.log("filtered transactions created & is length " + $scope.filtered_transactions.length);
					//$evalAsync($scope.allowed_units[clicked_button.label] = true);
			} else if (clicked_button.filter === true){
				filterFactory.remove_filter(clicked_button.screen, clicked_button.name);
				//$scope.filtered_transactions = reportFactory.filtered_transactions;
				//$scope.filtered_transactions = $filter('in_group')({'item_list': $scope.transaction_index, 'group': filterFactory.get(clicked_button.screen), 'property': clicked_button.screen}); 
				//console.log("filtered transactions created & is length " + $scope.filtered_transactions.length);
			}
			//console.log("Toggled a filter.  Current allowed units: " + JSON.stringify(filterFactory.get('unit')) + ".  Matching test returns " + JSON.stringify($filter('in_group')({'item_list': [{me: 'myself'}, {me: 'yourself'}, {me: 'himself'}], 'group': {'myself': true, 'yourself': true}, 'property': 'me'})));
			console.log("about to change clicked_button.filter from " + clicked_button.filter + " to " + !clicked_button.filter);
			clicked_button.filter = !clicked_button.filter;
		}
		/*$scope.unitFilter = function(actual, expected){
			if (expected['2']){
				console.log('unitfilter was tested by previous console log');
			} else {
				console.log("unitfilter was activated by something else: " + JSON.stringify(actual) + ', ' + JSON.stringify(expected));
			}
			if (Object.keys(expected).length === 0){
				return true;
			} else if (String(actual._unit.number) in expected){
				return true;
			} else {
				return false;
			}
		}
		$scope.typeFilter = function(actual, expected){
			if (Object.keys(expected).length === 0){
				return true;
			} else if (actual.type in expected){
				return true;
			} else {
				return false;
			}
		}*/
		console.log("done with filtercontroller script");
	}]);
	
/*
	myApp.controller('transactionsIndexController', ['$scope', 'transactionFactory', 'userFactory', function($scope, transactionFactory, userFactory){
		$scope.show_notes = false;
		$scope.edit_lock = {type: false, id: null};
		$scope.updated_transaction = {};
		$scope.collapsed = {};
		$scope.allowed_types = transactionFactory.allowed_types;
		$scope.date_for_sorting = transactionFactory.date_for_sorting;
		
		$scope.find_balance_index = function(){
			transactionFactory.index(function(result){
	    		if (result.error){
					userFactory.log('error', "Error retrieving transaction index: " + result.error);
				} else {
					$scope.index = result.index;
					$scope.index_by_unit = result.index_by_unit;
					userFactory.log('message', "Transaction index retrieved");
				}
    		})		
		}
		$scope.cancel = function(){
			$scope.edit_lock = {type: false, id: null};
			$scope.updated_transaction = {};
			userFactory.log('message', 'Action canceled.');
		}
		$scope.edit_transaction = function(this_transaction){
			$scope.updated_transaction = {_id: this_transaction._id, date: this_transaction.date, type: this_transaction.type, amount: (this_transaction.amount / 100).toFixed(2), check_number: this_transaction.check_number, notes: this_transaction.notes};
			$scope.edit_lock = {type: "edit", id: this_transaction._id};
			userFactory.log('message', 'Transaction prepped for editing.');
		}
		$scope.update_transaction = function(updated_transaction){
			transactionFactory.update(updated_transaction, function(result){
				if (result.error){
					userFactory.log('error', "Update error: " + result.error);
				} else {
					userFactory.log("message", "Update completed.  About to refresh transactions.");
					$scope.find_balance_index();
				}
			})
			$scope.edit_lock = {type: false, id: null};
			$scope.updated_transaction = {};
		}
		$scope.prepare_delete = function(id){
			$scope.edit_lock = {type: "delete", id: id};
		}
		$scope.delete_transaction = function(this_transaction, this_unit){
			transactionFactory.delete_one(this_transaction._id, function(result){
				if (result.error){
					userFactory.log('error', "Error deleting transaction: " + result.error);
				} else {
					var this_index = $scope.index_by_unit[this_unit].indexOf(this_transaction);
					$scope.index_by_unit[this_unit].splice(this_index, 1);
					$scope.edit_lock = {type: false, id: null};
					userFactory.log('message', "Transaction deleted.  Server response: " + JSON.stringify(result.result));
				}
			})
		}
	}]);
		factory.get_dues_list = function(unit_number, date, callback){
			var months = Number(date.getMonth()) + ((Number(date.getFullYear()) - 2011) * 12);
			$http.post('/trim_matrix', {unit: unit_number, months: months}).success(function(result){
				callback({dues_list: result.dues_list});
			})
		}
		factory.get_unit = function(unit_number, callback){ // this is almost a show unit method, but crops info in a report-specific manner
			var unit_url = '/units/' + unit_number;
			var unit_info = {};
			$http.post(unit_url).success(function(result){
				unit_info.credit_list = result.unit.credits;
				unit_info.late_fees = result.unit.late_fees;
				callback({unit_info: unit_info});
			})
		}
		factory.space_charges = function(charge_list, credit_list){
			for(i=1; i<credit_list.length; i++){
				if (credit_list[i].date.slice(0,2) == credit_list[i-1].date.slice(0,2)){
					charge_list.splice(i, 0, null); //inserts spaces in charge list that correspond to months that have more than one deposit date, so as to keep indexes in sync.
					//console.log("***MONTH OF " + credit_list[i].date + " IS " + credit_list[i].date.slice(0,2) + " IS EQUAL TO " + credit_list[i-1].date.slice(0,2) + " ADDED SPACE AT " + i + " with result " + charge_list + "***");
				}
				if (i == credit_list.length-1){
					return charge_list; 
				}
			}
		}
		$scope.toggle_collapse = function(unit_number){
			if (unit_number in $scope.collapsed){
				$scope.collapsed[unit_number] = !$scope.collapsed[unit_number];
				userFactory.log('message', "Unit " + unit_number + " collapse toggled: " + JSON.stringify($scope.collapsed));;
			} else {
				$scope.collapsed[unit_number] = true;
				userFactory.log('message', "Unit " + unit_number + " added to collapse menu: " + JSON.stringify($scope.collapsed));
			}
		}

		
		factory.logout_many = function(users, callback){ //not ideal, but currently anticipates that users is a list of user objects
			var this_index = function(){
				var current_index = -1;
				var increment = function(bump_or_tell){
					if (bump_or_tell === "bump"){
						current_index += 1;
						return current_index; //this appears to increment after sending value.
					} else if (bump_or_tell === "tell"){
						return current_index;
					}
				}
				return increment;
			}();
			var logged_out = [];
			var admin_index = users.indexOf({unit: "Admin"});
			if (admin_index != -1){
				users.splice(admin_index, 1);
			}
			for (i=0; i<users.length; i++){
				if (users[i].unit != "Admin"){
					factory.logout({unit: users[this_index('bump')].unit}, function(result){
						if (result.error){
							callback(result);
						} else if (result.logged_out){
							logged_out.push(result.unit);
							if (logged_out.length === users.length){
								callback ({result: true, logged_out: logged_out});
							} else {
								//console.log("not yet time to send mass logout response: " + users.length, + ", " + logged_out.length);
							}
						}
					})
				} else {
					this_index('bump');
				}
			}
		}
*/
	</script>
</head>
<body ng-app='myApp'>
 	<div ng-view></div>
	<!--<div class='display_table log'>
		<table ng-model='message_log'>Messsage Log |  <input type='submit' ng-click='message_log = []' value='Delete messages'>
			<tr ng-repeat='message in message_log track by $index'>
				<td ng-class='{error: message.type=="error"}' ng-bind='message.text'></td>
			</tr>
		</table>
	</div>-->
</body>

